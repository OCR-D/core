#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Nov  5 09:16:17 2019 by generateDS.py version 2.30.11.
# Python 3.6.6 (default, Jul 24 2018, 16:39:20)  [GCC 4.9.2]
#
# Command line options:
#   ('-f', '')
#   ('--root-element', 'alto')
#   ('-o', 'ocrd_models/ocrd_models/ocrd_alto_generateds.py')
#
# Command line arguments:
#   alto-4-1.xsd
#
# Command line:
#   /data/monorepo/venv3.6/bin/generateDS -f --root-element="alto" -o "ocrd_models/ocrd_models/ocrd_alto_generateds.py" alto-4-1.xsd
#
# Current working directory (os.getcwd()):
#   core
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class MeasurementUnitType(object):
    PIXEL='pixel'
    MM_10='mm10'
    INCH_1200='inch1200'


class PositionType(object):
    LEFT='Left'
    RIGHT='Right'
    FOLDOUT='Foldout'
    SINGLE='Single'
    COVER='Cover'


class QualityType(object):
    OK='OK'
    MISSING='Missing'
    MISSINGINORIGINAL='Missing in original'
    DAMAGED='Damaged'
    RETAINED='Retained'
    TARGET='Target'
    ASINORIGINAL='As in original'


class SUBS_TYPEType(object):
    HYP_PART_1='HypPart1'
    HYP_PART_2='HypPart2'
    ABBREVIATION='Abbreviation'


class fontStylesType(object):
    BOLD='bold'
    ITALICS='italics'
    SUBSCRIPT='subscript'
    SUPERSCRIPT='superscript'
    SMALLCAPS='smallcaps'
    UNDERLINE='underline'


class fontTypeType(object):
    SERIF='serif'
    SANSSERIF='sans-serif'


class fontWidthType(object):
    PROPORTIONAL='proportional'
    FIXED='fixed'


class processingCategoryType(object):
    CONTENT_GENERATION='contentGeneration'
    CONTENT_MODIFICATION='contentModification'
    PRE_OPERATION='preOperation'
    POST_OPERATION='postOperation'
    OTHER='other'


class altoType(GeneratedsSuper):
    """Schema version of the ALTO file."""
    subclass = None
    superclass = None
    def __init__(self, SCHEMAVERSION=None, Description=None, Styles=None, Tags=None, Layout=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.SCHEMAVERSION = _cast(None, SCHEMAVERSION)
        self.Description = Description
        self.Styles = Styles
        self.Tags = Tags
        self.Layout = Layout
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, altoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if altoType.subclass:
            return altoType.subclass(*args_, **kwargs_)
        else:
            return altoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self):
        return self.Description
    def set_Description(self, Description):
        self.Description = Description
    def get_Styles(self):
        return self.Styles
    def set_Styles(self, Styles):
        self.Styles = Styles
    def get_Tags(self):
        return self.Tags
    def set_Tags(self, Tags):
        self.Tags = Tags
    def get_Layout(self):
        return self.Layout
    def set_Layout(self, Layout):
        self.Layout = Layout
    def get_SCHEMAVERSION(self):
        return self.SCHEMAVERSION
    def set_SCHEMAVERSION(self, SCHEMAVERSION):
        self.SCHEMAVERSION = SCHEMAVERSION
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Styles is not None or
            self.Tags is not None or
            self.Layout is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='altoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('altoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='altoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='altoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='altoType'):
        if self.SCHEMAVERSION is not None and 'SCHEMAVERSION' not in already_processed:
            already_processed.add('SCHEMAVERSION')
            outfile.write(' SCHEMAVERSION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.SCHEMAVERSION), input_name='SCHEMAVERSION')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='altoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Description', pretty_print=pretty_print)
        if self.Styles is not None:
            self.Styles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Styles', pretty_print=pretty_print)
        if self.Tags is not None:
            self.Tags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tags', pretty_print=pretty_print)
        if self.Layout is not None:
            self.Layout.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Layout', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SCHEMAVERSION', node)
        if value is not None and 'SCHEMAVERSION' not in already_processed:
            already_processed.add('SCHEMAVERSION')
            self.SCHEMAVERSION = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = DescriptionType.factory(parent_object_=self)
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Styles':
            obj_ = StylesType.factory(parent_object_=self)
            obj_.build(child_)
            self.Styles = obj_
            obj_.original_tagname_ = 'Styles'
        elif nodeName_ == 'Tags':
            obj_ = TagsType.factory(parent_object_=self)
            obj_.build(child_)
            self.Tags = obj_
            obj_.original_tagname_ = 'Tags'
        elif nodeName_ == 'Layout':
            obj_ = LayoutType.factory(parent_object_=self)
            obj_.build(child_)
            self.Layout = obj_
            obj_.original_tagname_ = 'Layout'
# end class altoType


class DescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasurementUnit=None, sourceImageInformation=None, OCRProcessing=None, Processing=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.MeasurementUnit = MeasurementUnit
        self.validate_MeasurementUnitType(self.MeasurementUnit)
        self.sourceImageInformation = sourceImageInformation
        if OCRProcessing is None:
            self.OCRProcessing = []
        else:
            self.OCRProcessing = OCRProcessing
        if Processing is None:
            self.Processing = []
        else:
            self.Processing = Processing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptionType.subclass:
            return DescriptionType.subclass(*args_, **kwargs_)
        else:
            return DescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MeasurementUnit(self):
        return self.MeasurementUnit
    def set_MeasurementUnit(self, MeasurementUnit):
        self.MeasurementUnit = MeasurementUnit
    def get_sourceImageInformation(self):
        return self.sourceImageInformation
    def set_sourceImageInformation(self, sourceImageInformation):
        self.sourceImageInformation = sourceImageInformation
    def get_OCRProcessing(self):
        return self.OCRProcessing
    def set_OCRProcessing(self, OCRProcessing):
        self.OCRProcessing = OCRProcessing
    def add_OCRProcessing(self, value):
        self.OCRProcessing.append(value)
    def add_OCRProcessing(self, value):
        self.OCRProcessing.append(value)
    def insert_OCRProcessing_at(self, index, value):
        self.OCRProcessing.insert(index, value)
    def replace_OCRProcessing_at(self, index, value):
        self.OCRProcessing[index] = value
    def get_Processing(self):
        return self.Processing
    def set_Processing(self, Processing):
        self.Processing = Processing
    def add_Processing(self, value):
        self.Processing.append(value)
    def add_Processing(self, value):
        self.Processing.append(value)
    def insert_Processing_at(self, index, value):
        self.Processing.insert(index, value)
    def replace_Processing_at(self, index, value):
        self.Processing[index] = value
    def validate_MeasurementUnitType(self, value):
        # Validate type MeasurementUnitType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pixel', 'mm10', 'inch1200']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasurementUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasurementUnit is not None or
            self.sourceImageInformation is not None or
            self.OCRProcessing or
            self.Processing
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasurementUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurementUnit>%s</%sMeasurementUnit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasurementUnit), input_name='MeasurementUnit')), namespaceprefix_ , eol_))
        if self.sourceImageInformation is not None:
            self.sourceImageInformation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sourceImageInformation', pretty_print=pretty_print)
        for OCRProcessing_ in self.OCRProcessing:
            OCRProcessing_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OCRProcessing', pretty_print=pretty_print)
        for Processing_ in self.Processing:
            Processing_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Processing', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasurementUnit':
            MeasurementUnit_ = child_.text
            MeasurementUnit_ = self.gds_validate_string(MeasurementUnit_, node, 'MeasurementUnit')
            self.MeasurementUnit = MeasurementUnit_
            # validate type MeasurementUnitType
            self.validate_MeasurementUnitType(self.MeasurementUnit)
        elif nodeName_ == 'sourceImageInformation':
            obj_ = sourceImageInformationType.factory(parent_object_=self)
            obj_.build(child_)
            self.sourceImageInformation = obj_
            obj_.original_tagname_ = 'sourceImageInformation'
        elif nodeName_ == 'OCRProcessing':
            obj_ = OCRProcessingType.factory(parent_object_=self)
            obj_.build(child_)
            self.OCRProcessing.append(obj_)
            obj_.original_tagname_ = 'OCRProcessing'
        elif nodeName_ == 'Processing':
            obj_ = ProcessingType.factory(parent_object_=self)
            obj_.build(child_)
            self.Processing.append(obj_)
            obj_.original_tagname_ = 'Processing'
# end class DescriptionType


class StylesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TextStyle=None, ParagraphStyle=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if TextStyle is None:
            self.TextStyle = []
        else:
            self.TextStyle = TextStyle
        if ParagraphStyle is None:
            self.ParagraphStyle = []
        else:
            self.ParagraphStyle = ParagraphStyle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StylesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StylesType.subclass:
            return StylesType.subclass(*args_, **kwargs_)
        else:
            return StylesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextStyle(self):
        return self.TextStyle
    def set_TextStyle(self, TextStyle):
        self.TextStyle = TextStyle
    def add_TextStyle(self, value):
        self.TextStyle.append(value)
    def add_TextStyle(self, value):
        self.TextStyle.append(value)
    def insert_TextStyle_at(self, index, value):
        self.TextStyle.insert(index, value)
    def replace_TextStyle_at(self, index, value):
        self.TextStyle[index] = value
    def get_ParagraphStyle(self):
        return self.ParagraphStyle
    def set_ParagraphStyle(self, ParagraphStyle):
        self.ParagraphStyle = ParagraphStyle
    def add_ParagraphStyle(self, value):
        self.ParagraphStyle.append(value)
    def add_ParagraphStyle(self, value):
        self.ParagraphStyle.append(value)
    def insert_ParagraphStyle_at(self, index, value):
        self.ParagraphStyle.insert(index, value)
    def replace_ParagraphStyle_at(self, index, value):
        self.ParagraphStyle[index] = value
    def hasContent_(self):
        if (
            self.TextStyle or
            self.ParagraphStyle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StylesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StylesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StylesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StylesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StylesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StylesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TextStyle_ in self.TextStyle:
            TextStyle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextStyle', pretty_print=pretty_print)
        for ParagraphStyle_ in self.ParagraphStyle:
            ParagraphStyle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParagraphStyle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextStyle':
            obj_ = TextStyleType.factory(parent_object_=self)
            obj_.build(child_)
            self.TextStyle.append(obj_)
            obj_.original_tagname_ = 'TextStyle'
        elif nodeName_ == 'ParagraphStyle':
            obj_ = ParagraphStyleType.factory(parent_object_=self)
            obj_.build(child_)
            self.ParagraphStyle.append(obj_)
            obj_.original_tagname_ = 'ParagraphStyle'
# end class StylesType


class TagsType(GeneratedsSuper):
    """There are following variation of tag types available: LayoutTag –
    criteria about arrangement or graphical appearance StructureTag
    – criteria about grouping or formation RoleTag – criteria about
    function or mission NamedEntityTag – criteria about assignment
    of terms to their relationship / meaning (NER) OtherTag –
    criteria about any other characteristic not listed above, the
    TYPE attribute is intended to be used for classification within
    those."""
    subclass = None
    superclass = None
    def __init__(self, LayoutTag=None, StructureTag=None, RoleTag=None, NamedEntityTag=None, OtherTag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if LayoutTag is None:
            self.LayoutTag = []
        else:
            self.LayoutTag = LayoutTag
        if StructureTag is None:
            self.StructureTag = []
        else:
            self.StructureTag = StructureTag
        if RoleTag is None:
            self.RoleTag = []
        else:
            self.RoleTag = RoleTag
        if NamedEntityTag is None:
            self.NamedEntityTag = []
        else:
            self.NamedEntityTag = NamedEntityTag
        if OtherTag is None:
            self.OtherTag = []
        else:
            self.OtherTag = OtherTag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TagsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TagsType.subclass:
            return TagsType.subclass(*args_, **kwargs_)
        else:
            return TagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LayoutTag(self):
        return self.LayoutTag
    def set_LayoutTag(self, LayoutTag):
        self.LayoutTag = LayoutTag
    def add_LayoutTag(self, value):
        self.LayoutTag.append(value)
    def add_LayoutTag(self, value):
        self.LayoutTag.append(value)
    def insert_LayoutTag_at(self, index, value):
        self.LayoutTag.insert(index, value)
    def replace_LayoutTag_at(self, index, value):
        self.LayoutTag[index] = value
    def get_StructureTag(self):
        return self.StructureTag
    def set_StructureTag(self, StructureTag):
        self.StructureTag = StructureTag
    def add_StructureTag(self, value):
        self.StructureTag.append(value)
    def add_StructureTag(self, value):
        self.StructureTag.append(value)
    def insert_StructureTag_at(self, index, value):
        self.StructureTag.insert(index, value)
    def replace_StructureTag_at(self, index, value):
        self.StructureTag[index] = value
    def get_RoleTag(self):
        return self.RoleTag
    def set_RoleTag(self, RoleTag):
        self.RoleTag = RoleTag
    def add_RoleTag(self, value):
        self.RoleTag.append(value)
    def add_RoleTag(self, value):
        self.RoleTag.append(value)
    def insert_RoleTag_at(self, index, value):
        self.RoleTag.insert(index, value)
    def replace_RoleTag_at(self, index, value):
        self.RoleTag[index] = value
    def get_NamedEntityTag(self):
        return self.NamedEntityTag
    def set_NamedEntityTag(self, NamedEntityTag):
        self.NamedEntityTag = NamedEntityTag
    def add_NamedEntityTag(self, value):
        self.NamedEntityTag.append(value)
    def add_NamedEntityTag(self, value):
        self.NamedEntityTag.append(value)
    def insert_NamedEntityTag_at(self, index, value):
        self.NamedEntityTag.insert(index, value)
    def replace_NamedEntityTag_at(self, index, value):
        self.NamedEntityTag[index] = value
    def get_OtherTag(self):
        return self.OtherTag
    def set_OtherTag(self, OtherTag):
        self.OtherTag = OtherTag
    def add_OtherTag(self, value):
        self.OtherTag.append(value)
    def add_OtherTag(self, value):
        self.OtherTag.append(value)
    def insert_OtherTag_at(self, index, value):
        self.OtherTag.insert(index, value)
    def replace_OtherTag_at(self, index, value):
        self.OtherTag[index] = value
    def hasContent_(self):
        if (
            self.LayoutTag or
            self.StructureTag or
            self.RoleTag or
            self.NamedEntityTag or
            self.OtherTag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TagsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TagsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TagsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TagsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LayoutTag_ in self.LayoutTag:
            LayoutTag_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LayoutTag', pretty_print=pretty_print)
        for StructureTag_ in self.StructureTag:
            StructureTag_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StructureTag', pretty_print=pretty_print)
        for RoleTag_ in self.RoleTag:
            RoleTag_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RoleTag', pretty_print=pretty_print)
        for NamedEntityTag_ in self.NamedEntityTag:
            NamedEntityTag_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NamedEntityTag', pretty_print=pretty_print)
        for OtherTag_ in self.OtherTag:
            OtherTag_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OtherTag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LayoutTag':
            obj_ = TagType.factory(parent_object_=self)
            obj_.build(child_)
            self.LayoutTag.append(obj_)
            obj_.original_tagname_ = 'LayoutTag'
        elif nodeName_ == 'StructureTag':
            obj_ = TagType.factory(parent_object_=self)
            obj_.build(child_)
            self.StructureTag.append(obj_)
            obj_.original_tagname_ = 'StructureTag'
        elif nodeName_ == 'RoleTag':
            obj_ = TagType.factory(parent_object_=self)
            obj_.build(child_)
            self.RoleTag.append(obj_)
            obj_.original_tagname_ = 'RoleTag'
        elif nodeName_ == 'NamedEntityTag':
            obj_ = TagType.factory(parent_object_=self)
            obj_.build(child_)
            self.NamedEntityTag.append(obj_)
            obj_.original_tagname_ = 'NamedEntityTag'
        elif nodeName_ == 'OtherTag':
            obj_ = TagType.factory(parent_object_=self)
            obj_.build(child_)
            self.OtherTag.append(obj_)
            obj_.original_tagname_ = 'OtherTag'
# end class TagsType


class PageType(GeneratedsSuper):
    """One page of a book or journal.Any user-defined class like title
    page.The number of the page within the document.The page number
    that is printed on the page.A link to the processing description
    that has been used for this page.Estimated percentage of OCR
    Accuracy in range from 0 to 100"""
    subclass = None
    superclass = None
    def __init__(self, ID=None, PAGECLASS=None, STYLEREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, PHYSICAL_IMG_NR=None, PRINTED_IMG_NR=None, QUALITY=None, QUALITY_DETAIL=None, POSITION=None, PROCESSING=None, ACCURACY=None, PC=None, TopMargin=None, LeftMargin=None, RightMargin=None, BottomMargin=None, PrintSpace=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.PAGECLASS = _cast(None, PAGECLASS)
        self.STYLEREFS = _cast(None, STYLEREFS)
        self.PROCESSINGREFS = _cast(None, PROCESSINGREFS)
        self.HEIGHT = _cast(float, HEIGHT)
        self.WIDTH = _cast(float, WIDTH)
        self.PHYSICAL_IMG_NR = _cast(float, PHYSICAL_IMG_NR)
        self.PRINTED_IMG_NR = _cast(None, PRINTED_IMG_NR)
        self.QUALITY = _cast(None, QUALITY)
        self.QUALITY_DETAIL = _cast(None, QUALITY_DETAIL)
        self.POSITION = _cast(None, POSITION)
        self.PROCESSING = _cast(None, PROCESSING)
        self.ACCURACY = _cast(float, ACCURACY)
        self.PC = _cast(float, PC)
        self.TopMargin = TopMargin
        self.LeftMargin = LeftMargin
        self.RightMargin = RightMargin
        self.BottomMargin = BottomMargin
        self.PrintSpace = PrintSpace
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageType.subclass:
            return PageType.subclass(*args_, **kwargs_)
        else:
            return PageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopMargin(self):
        return self.TopMargin
    def set_TopMargin(self, TopMargin):
        self.TopMargin = TopMargin
    def get_LeftMargin(self):
        return self.LeftMargin
    def set_LeftMargin(self, LeftMargin):
        self.LeftMargin = LeftMargin
    def get_RightMargin(self):
        return self.RightMargin
    def set_RightMargin(self, RightMargin):
        self.RightMargin = RightMargin
    def get_BottomMargin(self):
        return self.BottomMargin
    def set_BottomMargin(self, BottomMargin):
        self.BottomMargin = BottomMargin
    def get_PrintSpace(self):
        return self.PrintSpace
    def set_PrintSpace(self, PrintSpace):
        self.PrintSpace = PrintSpace
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_PAGECLASS(self):
        return self.PAGECLASS
    def set_PAGECLASS(self, PAGECLASS):
        self.PAGECLASS = PAGECLASS
    def get_STYLEREFS(self):
        return self.STYLEREFS
    def set_STYLEREFS(self, STYLEREFS):
        self.STYLEREFS = STYLEREFS
    def get_PROCESSINGREFS(self):
        return self.PROCESSINGREFS
    def set_PROCESSINGREFS(self, PROCESSINGREFS):
        self.PROCESSINGREFS = PROCESSINGREFS
    def get_HEIGHT(self):
        return self.HEIGHT
    def set_HEIGHT(self, HEIGHT):
        self.HEIGHT = HEIGHT
    def get_WIDTH(self):
        return self.WIDTH
    def set_WIDTH(self, WIDTH):
        self.WIDTH = WIDTH
    def get_PHYSICAL_IMG_NR(self):
        return self.PHYSICAL_IMG_NR
    def set_PHYSICAL_IMG_NR(self, PHYSICAL_IMG_NR):
        self.PHYSICAL_IMG_NR = PHYSICAL_IMG_NR
    def get_PRINTED_IMG_NR(self):
        return self.PRINTED_IMG_NR
    def set_PRINTED_IMG_NR(self, PRINTED_IMG_NR):
        self.PRINTED_IMG_NR = PRINTED_IMG_NR
    def get_QUALITY(self):
        return self.QUALITY
    def set_QUALITY(self, QUALITY):
        self.QUALITY = QUALITY
    def get_QUALITY_DETAIL(self):
        return self.QUALITY_DETAIL
    def set_QUALITY_DETAIL(self, QUALITY_DETAIL):
        self.QUALITY_DETAIL = QUALITY_DETAIL
    def get_POSITION(self):
        return self.POSITION
    def set_POSITION(self, POSITION):
        self.POSITION = POSITION
    def get_PROCESSING(self):
        return self.PROCESSING
    def set_PROCESSING(self, PROCESSING):
        self.PROCESSING = PROCESSING
    def get_ACCURACY(self):
        return self.ACCURACY
    def set_ACCURACY(self, ACCURACY):
        self.ACCURACY = ACCURACY
    def get_PC(self):
        return self.PC
    def set_PC(self, PC):
        self.PC = PC
    def validate_PageID(self, value):
        # Validate type PageID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_QualityType(self, value):
        # Validate type QualityType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['OK', 'Missing', 'Missing in original', 'Damaged', 'Retained', 'Target', 'As in original']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QualityType' % {"value" : value.encode("utf-8")} )
    def validate_QualityDetailType(self, value):
        # Validate type QualityDetailType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PositionType(self, value):
        # Validate type PositionType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Left', 'Right', 'Foldout', 'Single', 'Cover']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PositionType' % {"value" : value.encode("utf-8")} )
    def validate_PCType(self, value):
        # Validate type PCType, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PCType' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PCType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TopMargin is not None or
            self.LeftMargin is not None or
            self.RightMargin is not None or
            self.BottomMargin is not None or
            self.PrintSpace is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.PAGECLASS is not None and 'PAGECLASS' not in already_processed:
            already_processed.add('PAGECLASS')
            outfile.write(' PAGECLASS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PAGECLASS), input_name='PAGECLASS')), ))
        if self.STYLEREFS is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            outfile.write(' STYLEREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STYLEREFS), input_name='STYLEREFS')), ))
        if self.PROCESSINGREFS is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            outfile.write(' PROCESSINGREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PROCESSINGREFS), input_name='PROCESSINGREFS')), ))
        if self.HEIGHT is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            outfile.write(' HEIGHT="%s"' % self.gds_format_float(self.HEIGHT, input_name='HEIGHT'))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH="%s"' % self.gds_format_float(self.WIDTH, input_name='WIDTH'))
        if self.PHYSICAL_IMG_NR is not None and 'PHYSICAL_IMG_NR' not in already_processed:
            already_processed.add('PHYSICAL_IMG_NR')
            outfile.write(' PHYSICAL_IMG_NR="%s"' % self.gds_format_float(self.PHYSICAL_IMG_NR, input_name='PHYSICAL_IMG_NR'))
        if self.PRINTED_IMG_NR is not None and 'PRINTED_IMG_NR' not in already_processed:
            already_processed.add('PRINTED_IMG_NR')
            outfile.write(' PRINTED_IMG_NR=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PRINTED_IMG_NR), input_name='PRINTED_IMG_NR')), ))
        if self.QUALITY is not None and 'QUALITY' not in already_processed:
            already_processed.add('QUALITY')
            outfile.write(' QUALITY=%s' % (quote_attrib(self.QUALITY), ))
        if self.QUALITY_DETAIL is not None and 'QUALITY_DETAIL' not in already_processed:
            already_processed.add('QUALITY_DETAIL')
            outfile.write(' QUALITY_DETAIL=%s' % (quote_attrib(self.QUALITY_DETAIL), ))
        if self.POSITION is not None and 'POSITION' not in already_processed:
            already_processed.add('POSITION')
            outfile.write(' POSITION=%s' % (quote_attrib(self.POSITION), ))
        if self.PROCESSING is not None and 'PROCESSING' not in already_processed:
            already_processed.add('PROCESSING')
            outfile.write(' PROCESSING=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PROCESSING), input_name='PROCESSING')), ))
        if self.ACCURACY is not None and 'ACCURACY' not in already_processed:
            already_processed.add('ACCURACY')
            outfile.write(' ACCURACY="%s"' % self.gds_format_float(self.ACCURACY, input_name='ACCURACY'))
        if self.PC is not None and 'PC' not in already_processed:
            already_processed.add('PC')
            outfile.write(' PC=%s' % (quote_attrib(self.PC), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TopMargin is not None:
            self.TopMargin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TopMargin', pretty_print=pretty_print)
        if self.LeftMargin is not None:
            self.LeftMargin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LeftMargin', pretty_print=pretty_print)
        if self.RightMargin is not None:
            self.RightMargin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RightMargin', pretty_print=pretty_print)
        if self.BottomMargin is not None:
            self.BottomMargin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BottomMargin', pretty_print=pretty_print)
        if self.PrintSpace is not None:
            self.PrintSpace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrintSpace', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_PageID(self.ID)    # validate type PageID
        value = find_attr_value_('PAGECLASS', node)
        if value is not None and 'PAGECLASS' not in already_processed:
            already_processed.add('PAGECLASS')
            self.PAGECLASS = value
        value = find_attr_value_('STYLEREFS', node)
        if value is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            self.STYLEREFS = value
        value = find_attr_value_('PROCESSINGREFS', node)
        if value is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            self.PROCESSINGREFS = value
        value = find_attr_value_('HEIGHT', node)
        if value is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            try:
                self.HEIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HEIGHT): %s' % exp)
        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            try:
                self.WIDTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WIDTH): %s' % exp)
        value = find_attr_value_('PHYSICAL_IMG_NR', node)
        if value is not None and 'PHYSICAL_IMG_NR' not in already_processed:
            already_processed.add('PHYSICAL_IMG_NR')
            try:
                self.PHYSICAL_IMG_NR = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PHYSICAL_IMG_NR): %s' % exp)
        value = find_attr_value_('PRINTED_IMG_NR', node)
        if value is not None and 'PRINTED_IMG_NR' not in already_processed:
            already_processed.add('PRINTED_IMG_NR')
            self.PRINTED_IMG_NR = value
        value = find_attr_value_('QUALITY', node)
        if value is not None and 'QUALITY' not in already_processed:
            already_processed.add('QUALITY')
            self.QUALITY = value
            self.validate_QualityType(self.QUALITY)    # validate type QualityType
        value = find_attr_value_('QUALITY_DETAIL', node)
        if value is not None and 'QUALITY_DETAIL' not in already_processed:
            already_processed.add('QUALITY_DETAIL')
            self.QUALITY_DETAIL = value
            self.validate_QualityDetailType(self.QUALITY_DETAIL)    # validate type QualityDetailType
        value = find_attr_value_('POSITION', node)
        if value is not None and 'POSITION' not in already_processed:
            already_processed.add('POSITION')
            self.POSITION = value
            self.validate_PositionType(self.POSITION)    # validate type PositionType
        value = find_attr_value_('PROCESSING', node)
        if value is not None and 'PROCESSING' not in already_processed:
            already_processed.add('PROCESSING')
            self.PROCESSING = value
        value = find_attr_value_('ACCURACY', node)
        if value is not None and 'ACCURACY' not in already_processed:
            already_processed.add('ACCURACY')
            try:
                self.ACCURACY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ACCURACY): %s' % exp)
        value = find_attr_value_('PC', node)
        if value is not None and 'PC' not in already_processed:
            already_processed.add('PC')
            try:
                self.PC = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PC): %s' % exp)
            self.validate_PCType(self.PC)    # validate type PCType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopMargin':
            obj_ = PageSpaceType.factory(parent_object_=self)
            obj_.build(child_)
            self.TopMargin = obj_
            obj_.original_tagname_ = 'TopMargin'
        elif nodeName_ == 'LeftMargin':
            obj_ = PageSpaceType.factory(parent_object_=self)
            obj_.build(child_)
            self.LeftMargin = obj_
            obj_.original_tagname_ = 'LeftMargin'
        elif nodeName_ == 'RightMargin':
            obj_ = PageSpaceType.factory(parent_object_=self)
            obj_.build(child_)
            self.RightMargin = obj_
            obj_.original_tagname_ = 'RightMargin'
        elif nodeName_ == 'BottomMargin':
            obj_ = PageSpaceType.factory(parent_object_=self)
            obj_.build(child_)
            self.BottomMargin = obj_
            obj_.original_tagname_ = 'BottomMargin'
        elif nodeName_ == 'PrintSpace':
            obj_ = PageSpaceType.factory(parent_object_=self)
            obj_.build(child_)
            self.PrintSpace = obj_
            obj_.original_tagname_ = 'PrintSpace'
# end class PageType


class LayoutType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, STYLEREFS=None, Page=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.STYLEREFS = _cast(None, STYLEREFS)
        if Page is None:
            self.Page = []
        else:
            self.Page = Page
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LayoutType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LayoutType.subclass:
            return LayoutType.subclass(*args_, **kwargs_)
        else:
            return LayoutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Page(self):
        return self.Page
    def set_Page(self, Page):
        self.Page = Page
    def add_Page(self, value):
        self.Page.append(value)
    def add_Page(self, value):
        self.Page.append(value)
    def insert_Page_at(self, index, value):
        self.Page.insert(index, value)
    def replace_Page_at(self, index, value):
        self.Page[index] = value
    def get_STYLEREFS(self):
        return self.STYLEREFS
    def set_STYLEREFS(self, STYLEREFS):
        self.STYLEREFS = STYLEREFS
    def hasContent_(self):
        if (
            self.Page
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LayoutType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LayoutType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LayoutType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LayoutType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LayoutType'):
        if self.STYLEREFS is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            outfile.write(' STYLEREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STYLEREFS), input_name='STYLEREFS')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LayoutType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Page_ in self.Page:
            Page_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Page', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('STYLEREFS', node)
        if value is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            self.STYLEREFS = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Page':
            obj_ = PageType.factory(parent_object_=self)
            obj_.build(child_)
            self.Page.append(obj_)
            obj_.original_tagname_ = 'Page'
# end class LayoutType


class TextStyleType(GeneratedsSuper):
    """A text style defines font properties of text."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, FONTFAMILY=None, FONTTYPE=None, FONTWIDTH=None, FONTSIZE=None, FONTCOLOR=None, FONTSTYLE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.FONTFAMILY = _cast(None, FONTFAMILY)
        self.FONTTYPE = _cast(None, FONTTYPE)
        self.FONTWIDTH = _cast(None, FONTWIDTH)
        self.FONTSIZE = _cast(float, FONTSIZE)
        self.FONTCOLOR = _cast(None, FONTCOLOR)
        self.FONTSTYLE = _cast(None, FONTSTYLE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextStyleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextStyleType.subclass:
            return TextStyleType.subclass(*args_, **kwargs_)
        else:
            return TextStyleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_FONTFAMILY(self):
        return self.FONTFAMILY
    def set_FONTFAMILY(self, FONTFAMILY):
        self.FONTFAMILY = FONTFAMILY
    def get_FONTTYPE(self):
        return self.FONTTYPE
    def set_FONTTYPE(self, FONTTYPE):
        self.FONTTYPE = FONTTYPE
    def get_FONTWIDTH(self):
        return self.FONTWIDTH
    def set_FONTWIDTH(self, FONTWIDTH):
        self.FONTWIDTH = FONTWIDTH
    def get_FONTSIZE(self):
        return self.FONTSIZE
    def set_FONTSIZE(self, FONTSIZE):
        self.FONTSIZE = FONTSIZE
    def get_FONTCOLOR(self):
        return self.FONTCOLOR
    def set_FONTCOLOR(self, FONTCOLOR):
        self.FONTCOLOR = FONTCOLOR
    def get_FONTSTYLE(self):
        return self.FONTSTYLE
    def set_FONTSTYLE(self, FONTSTYLE):
        self.FONTSTYLE = FONTSTYLE
    def validate_fontTypeType(self, value):
        # Validate type fontTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['serif', 'sans-serif']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on fontTypeType' % {"value" : value.encode("utf-8")} )
    def validate_fontWidthType(self, value):
        # Validate type fontWidthType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['proportional', 'fixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on fontWidthType' % {"value" : value.encode("utf-8")} )
    def validate_fontStylesType(self, value):
        # Validate type fontStylesType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on fontStylesType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextStyleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextStyleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextStyleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextStyleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextStyleType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.FONTFAMILY is not None and 'FONTFAMILY' not in already_processed:
            already_processed.add('FONTFAMILY')
            outfile.write(' FONTFAMILY=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FONTFAMILY), input_name='FONTFAMILY')), ))
        if self.FONTTYPE is not None and 'FONTTYPE' not in already_processed:
            already_processed.add('FONTTYPE')
            outfile.write(' FONTTYPE=%s' % (quote_attrib(self.FONTTYPE), ))
        if self.FONTWIDTH is not None and 'FONTWIDTH' not in already_processed:
            already_processed.add('FONTWIDTH')
            outfile.write(' FONTWIDTH=%s' % (quote_attrib(self.FONTWIDTH), ))
        if self.FONTSIZE is not None and 'FONTSIZE' not in already_processed:
            already_processed.add('FONTSIZE')
            outfile.write(' FONTSIZE="%s"' % self.gds_format_float(self.FONTSIZE, input_name='FONTSIZE'))
        if self.FONTCOLOR is not None and 'FONTCOLOR' not in already_processed:
            already_processed.add('FONTCOLOR')
            outfile.write(' FONTCOLOR=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FONTCOLOR), input_name='FONTCOLOR')), ))
        if self.FONTSTYLE is not None and 'FONTSTYLE' not in already_processed:
            already_processed.add('FONTSTYLE')
            outfile.write(' FONTSTYLE=%s' % (quote_attrib(self.FONTSTYLE), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextStyleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('FONTFAMILY', node)
        if value is not None and 'FONTFAMILY' not in already_processed:
            already_processed.add('FONTFAMILY')
            self.FONTFAMILY = value
        value = find_attr_value_('FONTTYPE', node)
        if value is not None and 'FONTTYPE' not in already_processed:
            already_processed.add('FONTTYPE')
            self.FONTTYPE = value
            self.validate_fontTypeType(self.FONTTYPE)    # validate type fontTypeType
        value = find_attr_value_('FONTWIDTH', node)
        if value is not None and 'FONTWIDTH' not in already_processed:
            already_processed.add('FONTWIDTH')
            self.FONTWIDTH = value
            self.validate_fontWidthType(self.FONTWIDTH)    # validate type fontWidthType
        value = find_attr_value_('FONTSIZE', node)
        if value is not None and 'FONTSIZE' not in already_processed:
            already_processed.add('FONTSIZE')
            try:
                self.FONTSIZE = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (FONTSIZE): %s' % exp)
        value = find_attr_value_('FONTCOLOR', node)
        if value is not None and 'FONTCOLOR' not in already_processed:
            already_processed.add('FONTCOLOR')
            self.FONTCOLOR = value
        value = find_attr_value_('FONTSTYLE', node)
        if value is not None and 'FONTSTYLE' not in already_processed:
            already_processed.add('FONTSTYLE')
            self.FONTSTYLE = value
            self.validate_fontStylesType(self.FONTSTYLE)    # validate type fontStylesType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TextStyleType


class ParagraphStyleType(GeneratedsSuper):
    """A paragraph style defines formatting properties of text
    blocks.Indicates the alignement of the paragraph. Could be left,
    right, center or justify.Left indent of the paragraph in
    relation to the column.Right indent of the paragraph in relation
    to the column.Line spacing between two lines of the paragraph.
    Measurement calculated from baseline to baseline.Indent of the
    first line of the paragraph if this is different from the other
    lines. A negative value indicates an indent to the left, a
    positive value indicates an indent to the right."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, ALIGN=None, LEFT=None, RIGHT=None, LINESPACE=None, FIRSTLINE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.ALIGN = _cast(None, ALIGN)
        self.LEFT = _cast(float, LEFT)
        self.RIGHT = _cast(float, RIGHT)
        self.LINESPACE = _cast(float, LINESPACE)
        self.FIRSTLINE = _cast(float, FIRSTLINE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParagraphStyleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParagraphStyleType.subclass:
            return ParagraphStyleType.subclass(*args_, **kwargs_)
        else:
            return ParagraphStyleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ALIGN(self):
        return self.ALIGN
    def set_ALIGN(self, ALIGN):
        self.ALIGN = ALIGN
    def get_LEFT(self):
        return self.LEFT
    def set_LEFT(self, LEFT):
        self.LEFT = LEFT
    def get_RIGHT(self):
        return self.RIGHT
    def set_RIGHT(self, RIGHT):
        self.RIGHT = RIGHT
    def get_LINESPACE(self):
        return self.LINESPACE
    def set_LINESPACE(self, LINESPACE):
        self.LINESPACE = LINESPACE
    def get_FIRSTLINE(self):
        return self.FIRSTLINE
    def set_FIRSTLINE(self, FIRSTLINE):
        self.FIRSTLINE = FIRSTLINE
    def validate_ParagraphStyleID(self, value):
        # Validate type ParagraphStyleID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParagraphStyleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParagraphStyleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParagraphStyleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParagraphStyleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParagraphStyleType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.ALIGN is not None and 'ALIGN' not in already_processed:
            already_processed.add('ALIGN')
            outfile.write(' ALIGN=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ALIGN), input_name='ALIGN')), ))
        if self.LEFT is not None and 'LEFT' not in already_processed:
            already_processed.add('LEFT')
            outfile.write(' LEFT="%s"' % self.gds_format_float(self.LEFT, input_name='LEFT'))
        if self.RIGHT is not None and 'RIGHT' not in already_processed:
            already_processed.add('RIGHT')
            outfile.write(' RIGHT="%s"' % self.gds_format_float(self.RIGHT, input_name='RIGHT'))
        if self.LINESPACE is not None and 'LINESPACE' not in already_processed:
            already_processed.add('LINESPACE')
            outfile.write(' LINESPACE="%s"' % self.gds_format_float(self.LINESPACE, input_name='LINESPACE'))
        if self.FIRSTLINE is not None and 'FIRSTLINE' not in already_processed:
            already_processed.add('FIRSTLINE')
            outfile.write(' FIRSTLINE="%s"' % self.gds_format_float(self.FIRSTLINE, input_name='FIRSTLINE'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParagraphStyleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ParagraphStyleID(self.ID)    # validate type ParagraphStyleID
        value = find_attr_value_('ALIGN', node)
        if value is not None and 'ALIGN' not in already_processed:
            already_processed.add('ALIGN')
            self.ALIGN = value
        value = find_attr_value_('LEFT', node)
        if value is not None and 'LEFT' not in already_processed:
            already_processed.add('LEFT')
            try:
                self.LEFT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LEFT): %s' % exp)
        value = find_attr_value_('RIGHT', node)
        if value is not None and 'RIGHT' not in already_processed:
            already_processed.add('RIGHT')
            try:
                self.RIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (RIGHT): %s' % exp)
        value = find_attr_value_('LINESPACE', node)
        if value is not None and 'LINESPACE' not in already_processed:
            already_processed.add('LINESPACE')
            try:
                self.LINESPACE = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LINESPACE): %s' % exp)
        value = find_attr_value_('FIRSTLINE', node)
        if value is not None and 'FIRSTLINE' not in already_processed:
            already_processed.add('FIRSTLINE')
            try:
                self.FIRSTLINE = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (FIRSTLINE): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParagraphStyleType


class BlockType(GeneratedsSuper):
    """Base type for any kind of block on the page.Tells the rotation of
    e.g. text or illustration within the block. The value is in
    degree counterclockwise.The next block in reading sequence on
    the page.Correction Status. Indicates whether manual correction
    has been done or not. The correction status should be recorded
    at the highest level possible (Block, TextLine, String)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, STYLEREFS=None, TAGREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, ROTATION=None, IDNEXT=None, CS=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, Shape=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.STYLEREFS = _cast(None, STYLEREFS)
        self.TAGREFS = _cast(None, TAGREFS)
        self.PROCESSINGREFS = _cast(None, PROCESSINGREFS)
        self.HEIGHT = _cast(float, HEIGHT)
        self.WIDTH = _cast(float, WIDTH)
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
        self.ROTATION = _cast(float, ROTATION)
        self.IDNEXT = _cast(None, IDNEXT)
        self.CS = _cast(bool, CS)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.Shape = Shape
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockType.subclass:
            return BlockType.subclass(*args_, **kwargs_)
        else:
            return BlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Shape(self):
        return self.Shape
    def set_Shape(self, Shape):
        self.Shape = Shape
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_STYLEREFS(self):
        return self.STYLEREFS
    def set_STYLEREFS(self, STYLEREFS):
        self.STYLEREFS = STYLEREFS
    def get_TAGREFS(self):
        return self.TAGREFS
    def set_TAGREFS(self, TAGREFS):
        self.TAGREFS = TAGREFS
    def get_PROCESSINGREFS(self):
        return self.PROCESSINGREFS
    def set_PROCESSINGREFS(self, PROCESSINGREFS):
        self.PROCESSINGREFS = PROCESSINGREFS
    def get_HEIGHT(self):
        return self.HEIGHT
    def set_HEIGHT(self, HEIGHT):
        self.HEIGHT = HEIGHT
    def get_WIDTH(self):
        return self.WIDTH
    def set_WIDTH(self, WIDTH):
        self.WIDTH = WIDTH
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def get_ROTATION(self):
        return self.ROTATION
    def set_ROTATION(self, ROTATION):
        self.ROTATION = ROTATION
    def get_IDNEXT(self):
        return self.IDNEXT
    def set_IDNEXT(self, IDNEXT):
        self.IDNEXT = IDNEXT
    def get_CS(self):
        return self.CS
    def set_CS(self, CS):
        self.CS = CS
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BlockTypeID(self, value):
        # Validate type BlockTypeID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Shape is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BlockType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.STYLEREFS is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            outfile.write(' STYLEREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STYLEREFS), input_name='STYLEREFS')), ))
        if self.TAGREFS is not None and 'TAGREFS' not in already_processed:
            already_processed.add('TAGREFS')
            outfile.write(' TAGREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TAGREFS), input_name='TAGREFS')), ))
        if self.PROCESSINGREFS is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            outfile.write(' PROCESSINGREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PROCESSINGREFS), input_name='PROCESSINGREFS')), ))
        if self.HEIGHT is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            outfile.write(' HEIGHT="%s"' % self.gds_format_float(self.HEIGHT, input_name='HEIGHT'))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH="%s"' % self.gds_format_float(self.WIDTH, input_name='WIDTH'))
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
        if self.ROTATION is not None and 'ROTATION' not in already_processed:
            already_processed.add('ROTATION')
            outfile.write(' ROTATION="%s"' % self.gds_format_float(self.ROTATION, input_name='ROTATION'))
        if self.IDNEXT is not None and 'IDNEXT' not in already_processed:
            already_processed.add('IDNEXT')
            outfile.write(' IDNEXT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDNEXT), input_name='IDNEXT')), ))
        if self.CS is not None and 'CS' not in already_processed:
            already_processed.add('CS')
            outfile.write(' CS="%s"' % self.gds_format_boolean(self.CS, input_name='CS'))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Shape is not None:
            self.Shape.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Shape', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_BlockTypeID(self.ID)    # validate type BlockTypeID
        value = find_attr_value_('STYLEREFS', node)
        if value is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            self.STYLEREFS = value
        value = find_attr_value_('TAGREFS', node)
        if value is not None and 'TAGREFS' not in already_processed:
            already_processed.add('TAGREFS')
            self.TAGREFS = value
        value = find_attr_value_('PROCESSINGREFS', node)
        if value is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            self.PROCESSINGREFS = value
        value = find_attr_value_('HEIGHT', node)
        if value is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            try:
                self.HEIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HEIGHT): %s' % exp)
        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            try:
                self.WIDTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WIDTH): %s' % exp)
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
        value = find_attr_value_('ROTATION', node)
        if value is not None and 'ROTATION' not in already_processed:
            already_processed.add('ROTATION')
            try:
                self.ROTATION = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ROTATION): %s' % exp)
        value = find_attr_value_('IDNEXT', node)
        if value is not None and 'IDNEXT' not in already_processed:
            already_processed.add('IDNEXT')
            self.IDNEXT = value
        value = find_attr_value_('CS', node)
        if value is not None and 'CS' not in already_processed:
            already_processed.add('CS')
            if value in ('true', '1'):
                self.CS = True
            elif value in ('false', '0'):
                self.CS = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Shape':
            obj_ = ShapeType.factory(parent_object_=self)
            obj_.build(child_)
            self.Shape = obj_
            obj_.original_tagname_ = 'Shape'
# end class BlockType


class SPType(GeneratedsSuper):
    """A white space."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.HEIGHT = _cast(float, HEIGHT)
        self.WIDTH = _cast(float, WIDTH)
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPType.subclass:
            return SPType.subclass(*args_, **kwargs_)
        else:
            return SPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_HEIGHT(self):
        return self.HEIGHT
    def set_HEIGHT(self, HEIGHT):
        self.HEIGHT = HEIGHT
    def get_WIDTH(self):
        return self.WIDTH
    def set_WIDTH(self, WIDTH):
        self.WIDTH = WIDTH
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def validate_SPTypeID(self, value):
        # Validate type SPTypeID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SPType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SPType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SPType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.HEIGHT is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            outfile.write(' HEIGHT="%s"' % self.gds_format_float(self.HEIGHT, input_name='HEIGHT'))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH="%s"' % self.gds_format_float(self.WIDTH, input_name='WIDTH'))
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SPType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_SPTypeID(self.ID)    # validate type SPTypeID
        value = find_attr_value_('HEIGHT', node)
        if value is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            try:
                self.HEIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HEIGHT): %s' % exp)
        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            try:
                self.WIDTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WIDTH): %s' % exp)
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SPType


class ALTERNATIVEType(GeneratedsSuper):
    """Any alternative for the word. Alternative can outline a variant of
    writing by new typing / spelling rules, typically manually done
    or by dictionary replacements. The above sample is an old
    composed character "Æ" of ancient time, which is replaced now by
    "Ä". As variant are meant alternatives of the real printed
    content which are options outlined by the text recognition
    process. Similar sample: "Straße" vs. "Strasse". Such
    alternatives are not coming from text recognition. Identifies
    the purpose of the alternative."""
    subclass = None
    superclass = None
    def __init__(self, PURPOSE=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.PURPOSE = _cast(None, PURPOSE)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ALTERNATIVEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ALTERNATIVEType.subclass:
            return ALTERNATIVEType.subclass(*args_, **kwargs_)
        else:
            return ALTERNATIVEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PURPOSE(self):
        return self.PURPOSE
    def set_PURPOSE(self, PURPOSE):
        self.PURPOSE = PURPOSE
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ALTERNATIVEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ALTERNATIVEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ALTERNATIVEType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ALTERNATIVEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ALTERNATIVEType'):
        if self.PURPOSE is not None and 'PURPOSE' not in already_processed:
            already_processed.add('PURPOSE')
            outfile.write(' PURPOSE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PURPOSE), input_name='PURPOSE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ALTERNATIVEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PURPOSE', node)
        if value is not None and 'PURPOSE' not in already_processed:
            already_processed.add('PURPOSE')
            self.PURPOSE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ALTERNATIVEType


class StringType(GeneratedsSuper):
    """A sequence of chars. Strings are separated by white spaces or
    hyphenation chars.Content of the substitution.Confidence level
    of each character in that string. A list of numbers, one number
    between 0 (sure) and 9 (unsure) for each character.Correction
    Status. Indicates whether manual correction has been done or
    not. The correction status should be recorded at the highest
    level possible (Block, TextLine, String).Attribute to record
    language of the string. The language should be recorded at the
    highest level possible."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, STYLEREFS=None, TAGREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, CONTENT=None, STYLE=None, SUBS_TYPE=None, SUBS_CONTENT=None, WC=None, CC=None, CS=None, LANG=None, Shape=None, ALTERNATIVE=None, Glyph=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.STYLEREFS = _cast(None, STYLEREFS)
        self.TAGREFS = _cast(None, TAGREFS)
        self.PROCESSINGREFS = _cast(None, PROCESSINGREFS)
        self.HEIGHT = _cast(float, HEIGHT)
        self.WIDTH = _cast(float, WIDTH)
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
        self.CONTENT = _cast(None, CONTENT)
        self.STYLE = _cast(None, STYLE)
        self.SUBS_TYPE = _cast(None, SUBS_TYPE)
        self.SUBS_CONTENT = _cast(None, SUBS_CONTENT)
        self.WC = _cast(float, WC)
        self.CC = _cast(None, CC)
        self.CS = _cast(bool, CS)
        self.LANG = _cast(None, LANG)
        self.Shape = Shape
        if ALTERNATIVE is None:
            self.ALTERNATIVE = []
        else:
            self.ALTERNATIVE = ALTERNATIVE
        if Glyph is None:
            self.Glyph = []
        else:
            self.Glyph = Glyph
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringType.subclass:
            return StringType.subclass(*args_, **kwargs_)
        else:
            return StringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Shape(self):
        return self.Shape
    def set_Shape(self, Shape):
        self.Shape = Shape
    def get_ALTERNATIVE(self):
        return self.ALTERNATIVE
    def set_ALTERNATIVE(self, ALTERNATIVE):
        self.ALTERNATIVE = ALTERNATIVE
    def add_ALTERNATIVE(self, value):
        self.ALTERNATIVE.append(value)
    def add_ALTERNATIVE(self, value):
        self.ALTERNATIVE.append(value)
    def insert_ALTERNATIVE_at(self, index, value):
        self.ALTERNATIVE.insert(index, value)
    def replace_ALTERNATIVE_at(self, index, value):
        self.ALTERNATIVE[index] = value
    def get_Glyph(self):
        return self.Glyph
    def set_Glyph(self, Glyph):
        self.Glyph = Glyph
    def add_Glyph(self, value):
        self.Glyph.append(value)
    def add_Glyph(self, value):
        self.Glyph.append(value)
    def insert_Glyph_at(self, index, value):
        self.Glyph.insert(index, value)
    def replace_Glyph_at(self, index, value):
        self.Glyph[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_STYLEREFS(self):
        return self.STYLEREFS
    def set_STYLEREFS(self, STYLEREFS):
        self.STYLEREFS = STYLEREFS
    def get_TAGREFS(self):
        return self.TAGREFS
    def set_TAGREFS(self, TAGREFS):
        self.TAGREFS = TAGREFS
    def get_PROCESSINGREFS(self):
        return self.PROCESSINGREFS
    def set_PROCESSINGREFS(self, PROCESSINGREFS):
        self.PROCESSINGREFS = PROCESSINGREFS
    def get_HEIGHT(self):
        return self.HEIGHT
    def set_HEIGHT(self, HEIGHT):
        self.HEIGHT = HEIGHT
    def get_WIDTH(self):
        return self.WIDTH
    def set_WIDTH(self, WIDTH):
        self.WIDTH = WIDTH
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def get_CONTENT(self):
        return self.CONTENT
    def set_CONTENT(self, CONTENT):
        self.CONTENT = CONTENT
    def get_STYLE(self):
        return self.STYLE
    def set_STYLE(self, STYLE):
        self.STYLE = STYLE
    def get_SUBS_TYPE(self):
        return self.SUBS_TYPE
    def set_SUBS_TYPE(self, SUBS_TYPE):
        self.SUBS_TYPE = SUBS_TYPE
    def get_SUBS_CONTENT(self):
        return self.SUBS_CONTENT
    def set_SUBS_CONTENT(self, SUBS_CONTENT):
        self.SUBS_CONTENT = SUBS_CONTENT
    def get_WC(self):
        return self.WC
    def set_WC(self, WC):
        self.WC = WC
    def get_CC(self):
        return self.CC
    def set_CC(self, CC):
        self.CC = CC
    def get_CS(self):
        return self.CS
    def set_CS(self, CS):
        self.CS = CS
    def get_LANG(self):
        return self.LANG
    def set_LANG(self, LANG):
        self.LANG = LANG
    def validate_StringTypeID(self, value):
        # Validate type StringTypeID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_CONTENTType(self, value):
        # Validate type CONTENTType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_fontStylesType(self, value):
        # Validate type fontStylesType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on fontStylesType' % {"value" : value.encode("utf-8")} )
    def validate_SUBS_TYPEType(self, value):
        # Validate type SUBS_TYPEType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HypPart1', 'HypPart2', 'Abbreviation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SUBS_TYPEType' % {"value" : value.encode("utf-8")} )
    def validate_WCType(self, value):
        # Validate type WCType, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on WCType' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WCType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Shape is not None or
            self.ALTERNATIVE or
            self.Glyph
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.STYLEREFS is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            outfile.write(' STYLEREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STYLEREFS), input_name='STYLEREFS')), ))
        if self.TAGREFS is not None and 'TAGREFS' not in already_processed:
            already_processed.add('TAGREFS')
            outfile.write(' TAGREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TAGREFS), input_name='TAGREFS')), ))
        if self.PROCESSINGREFS is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            outfile.write(' PROCESSINGREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PROCESSINGREFS), input_name='PROCESSINGREFS')), ))
        if self.HEIGHT is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            outfile.write(' HEIGHT="%s"' % self.gds_format_float(self.HEIGHT, input_name='HEIGHT'))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH="%s"' % self.gds_format_float(self.WIDTH, input_name='WIDTH'))
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
        if self.CONTENT is not None and 'CONTENT' not in already_processed:
            already_processed.add('CONTENT')
            outfile.write(' CONTENT=%s' % (quote_attrib(self.CONTENT), ))
        if self.STYLE is not None and 'STYLE' not in already_processed:
            already_processed.add('STYLE')
            outfile.write(' STYLE=%s' % (quote_attrib(self.STYLE), ))
        if self.SUBS_TYPE is not None and 'SUBS_TYPE' not in already_processed:
            already_processed.add('SUBS_TYPE')
            outfile.write(' SUBS_TYPE=%s' % (quote_attrib(self.SUBS_TYPE), ))
        if self.SUBS_CONTENT is not None and 'SUBS_CONTENT' not in already_processed:
            already_processed.add('SUBS_CONTENT')
            outfile.write(' SUBS_CONTENT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.SUBS_CONTENT), input_name='SUBS_CONTENT')), ))
        if self.WC is not None and 'WC' not in already_processed:
            already_processed.add('WC')
            outfile.write(' WC=%s' % (quote_attrib(self.WC), ))
        if self.CC is not None and 'CC' not in already_processed:
            already_processed.add('CC')
            outfile.write(' CC=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CC), input_name='CC')), ))
        if self.CS is not None and 'CS' not in already_processed:
            already_processed.add('CS')
            outfile.write(' CS="%s"' % self.gds_format_boolean(self.CS, input_name='CS'))
        if self.LANG is not None and 'LANG' not in already_processed:
            already_processed.add('LANG')
            outfile.write(' LANG=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG), input_name='LANG')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Shape is not None:
            self.Shape.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Shape', pretty_print=pretty_print)
        for ALTERNATIVE_ in self.ALTERNATIVE:
            ALTERNATIVE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ALTERNATIVE', pretty_print=pretty_print)
        for Glyph_ in self.Glyph:
            Glyph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Glyph', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_StringTypeID(self.ID)    # validate type StringTypeID
        value = find_attr_value_('STYLEREFS', node)
        if value is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            self.STYLEREFS = value
        value = find_attr_value_('TAGREFS', node)
        if value is not None and 'TAGREFS' not in already_processed:
            already_processed.add('TAGREFS')
            self.TAGREFS = value
        value = find_attr_value_('PROCESSINGREFS', node)
        if value is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            self.PROCESSINGREFS = value
        value = find_attr_value_('HEIGHT', node)
        if value is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            try:
                self.HEIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HEIGHT): %s' % exp)
        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            try:
                self.WIDTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WIDTH): %s' % exp)
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
        value = find_attr_value_('CONTENT', node)
        if value is not None and 'CONTENT' not in already_processed:
            already_processed.add('CONTENT')
            self.CONTENT = value
            self.validate_CONTENTType(self.CONTENT)    # validate type CONTENTType
        value = find_attr_value_('STYLE', node)
        if value is not None and 'STYLE' not in already_processed:
            already_processed.add('STYLE')
            self.STYLE = value
            self.validate_fontStylesType(self.STYLE)    # validate type fontStylesType
        value = find_attr_value_('SUBS_TYPE', node)
        if value is not None and 'SUBS_TYPE' not in already_processed:
            already_processed.add('SUBS_TYPE')
            self.SUBS_TYPE = value
            self.validate_SUBS_TYPEType(self.SUBS_TYPE)    # validate type SUBS_TYPEType
        value = find_attr_value_('SUBS_CONTENT', node)
        if value is not None and 'SUBS_CONTENT' not in already_processed:
            already_processed.add('SUBS_CONTENT')
            self.SUBS_CONTENT = value
        value = find_attr_value_('WC', node)
        if value is not None and 'WC' not in already_processed:
            already_processed.add('WC')
            try:
                self.WC = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WC): %s' % exp)
            self.validate_WCType(self.WC)    # validate type WCType
        value = find_attr_value_('CC', node)
        if value is not None and 'CC' not in already_processed:
            already_processed.add('CC')
            self.CC = value
        value = find_attr_value_('CS', node)
        if value is not None and 'CS' not in already_processed:
            already_processed.add('CS')
            if value in ('true', '1'):
                self.CS = True
            elif value in ('false', '0'):
                self.CS = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('LANG', node)
        if value is not None and 'LANG' not in already_processed:
            already_processed.add('LANG')
            self.LANG = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Shape':
            obj_ = ShapeType.factory(parent_object_=self)
            obj_.build(child_)
            self.Shape = obj_
            obj_.original_tagname_ = 'Shape'
        elif nodeName_ == 'ALTERNATIVE':
            obj_ = ALTERNATIVEType.factory(parent_object_=self)
            obj_.build(child_)
            self.ALTERNATIVE.append(obj_)
            obj_.original_tagname_ = 'ALTERNATIVE'
        elif nodeName_ == 'Glyph':
            obj_ = GlyphType.factory(parent_object_=self)
            obj_.build(child_)
            self.Glyph.append(obj_)
            obj_.original_tagname_ = 'Glyph'
# end class StringType


class PageSpaceType(GeneratedsSuper):
    """A region on a page"""
    subclass = None
    superclass = None
    def __init__(self, ID=None, STYLEREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, Shape=None, TextBlock=None, Illustration=None, GraphicalElement=None, ComposedBlock=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.STYLEREFS = _cast(None, STYLEREFS)
        self.PROCESSINGREFS = _cast(None, PROCESSINGREFS)
        self.HEIGHT = _cast(float, HEIGHT)
        self.WIDTH = _cast(float, WIDTH)
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
        self.Shape = Shape
        if TextBlock is None:
            self.TextBlock = []
        else:
            self.TextBlock = TextBlock
        if Illustration is None:
            self.Illustration = []
        else:
            self.Illustration = Illustration
        if GraphicalElement is None:
            self.GraphicalElement = []
        else:
            self.GraphicalElement = GraphicalElement
        if ComposedBlock is None:
            self.ComposedBlock = []
        else:
            self.ComposedBlock = ComposedBlock
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageSpaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageSpaceType.subclass:
            return PageSpaceType.subclass(*args_, **kwargs_)
        else:
            return PageSpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Shape(self):
        return self.Shape
    def set_Shape(self, Shape):
        self.Shape = Shape
    def get_TextBlock(self):
        return self.TextBlock
    def set_TextBlock(self, TextBlock):
        self.TextBlock = TextBlock
    def add_TextBlock(self, value):
        self.TextBlock.append(value)
    def add_TextBlock(self, value):
        self.TextBlock.append(value)
    def insert_TextBlock_at(self, index, value):
        self.TextBlock.insert(index, value)
    def replace_TextBlock_at(self, index, value):
        self.TextBlock[index] = value
    def get_Illustration(self):
        return self.Illustration
    def set_Illustration(self, Illustration):
        self.Illustration = Illustration
    def add_Illustration(self, value):
        self.Illustration.append(value)
    def add_Illustration(self, value):
        self.Illustration.append(value)
    def insert_Illustration_at(self, index, value):
        self.Illustration.insert(index, value)
    def replace_Illustration_at(self, index, value):
        self.Illustration[index] = value
    def get_GraphicalElement(self):
        return self.GraphicalElement
    def set_GraphicalElement(self, GraphicalElement):
        self.GraphicalElement = GraphicalElement
    def add_GraphicalElement(self, value):
        self.GraphicalElement.append(value)
    def add_GraphicalElement(self, value):
        self.GraphicalElement.append(value)
    def insert_GraphicalElement_at(self, index, value):
        self.GraphicalElement.insert(index, value)
    def replace_GraphicalElement_at(self, index, value):
        self.GraphicalElement[index] = value
    def get_ComposedBlock(self):
        return self.ComposedBlock
    def set_ComposedBlock(self, ComposedBlock):
        self.ComposedBlock = ComposedBlock
    def add_ComposedBlock(self, value):
        self.ComposedBlock.append(value)
    def add_ComposedBlock(self, value):
        self.ComposedBlock.append(value)
    def insert_ComposedBlock_at(self, index, value):
        self.ComposedBlock.insert(index, value)
    def replace_ComposedBlock_at(self, index, value):
        self.ComposedBlock[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_STYLEREFS(self):
        return self.STYLEREFS
    def set_STYLEREFS(self, STYLEREFS):
        self.STYLEREFS = STYLEREFS
    def get_PROCESSINGREFS(self):
        return self.PROCESSINGREFS
    def set_PROCESSINGREFS(self, PROCESSINGREFS):
        self.PROCESSINGREFS = PROCESSINGREFS
    def get_HEIGHT(self):
        return self.HEIGHT
    def set_HEIGHT(self, HEIGHT):
        self.HEIGHT = HEIGHT
    def get_WIDTH(self):
        return self.WIDTH
    def set_WIDTH(self, WIDTH):
        self.WIDTH = WIDTH
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def validate_PageSpaceTypeID(self, value):
        # Validate type PageSpaceTypeID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Shape is not None or
            self.TextBlock or
            self.Illustration or
            self.GraphicalElement or
            self.ComposedBlock
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageSpaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageSpaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageSpaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageSpaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageSpaceType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.STYLEREFS is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            outfile.write(' STYLEREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STYLEREFS), input_name='STYLEREFS')), ))
        if self.PROCESSINGREFS is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            outfile.write(' PROCESSINGREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PROCESSINGREFS), input_name='PROCESSINGREFS')), ))
        if self.HEIGHT is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            outfile.write(' HEIGHT="%s"' % self.gds_format_float(self.HEIGHT, input_name='HEIGHT'))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH="%s"' % self.gds_format_float(self.WIDTH, input_name='WIDTH'))
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageSpaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Shape is not None:
            self.Shape.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Shape', pretty_print=pretty_print)
        for TextBlock_ in self.TextBlock:
            TextBlock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextBlock', pretty_print=pretty_print)
        for Illustration_ in self.Illustration:
            Illustration_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Illustration', pretty_print=pretty_print)
        for GraphicalElement_ in self.GraphicalElement:
            GraphicalElement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GraphicalElement', pretty_print=pretty_print)
        for ComposedBlock_ in self.ComposedBlock:
            ComposedBlock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComposedBlock', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_PageSpaceTypeID(self.ID)    # validate type PageSpaceTypeID
        value = find_attr_value_('STYLEREFS', node)
        if value is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            self.STYLEREFS = value
        value = find_attr_value_('PROCESSINGREFS', node)
        if value is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            self.PROCESSINGREFS = value
        value = find_attr_value_('HEIGHT', node)
        if value is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            try:
                self.HEIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HEIGHT): %s' % exp)
        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            try:
                self.WIDTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WIDTH): %s' % exp)
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Shape':
            obj_ = ShapeType.factory(parent_object_=self)
            obj_.build(child_)
            self.Shape = obj_
            obj_.original_tagname_ = 'Shape'
        elif nodeName_ == 'TextBlock':
            obj_ = TextBlockType.factory(parent_object_=self)
            obj_.build(child_)
            self.TextBlock.append(obj_)
            obj_.original_tagname_ = 'TextBlock'
        elif nodeName_ == 'Illustration':
            obj_ = IllustrationType.factory(parent_object_=self)
            obj_.build(child_)
            self.Illustration.append(obj_)
            obj_.original_tagname_ = 'Illustration'
        elif nodeName_ == 'GraphicalElement':
            obj_ = GraphicalElementType.factory(parent_object_=self)
            obj_.build(child_)
            self.GraphicalElement.append(obj_)
            obj_.original_tagname_ = 'GraphicalElement'
        elif nodeName_ == 'ComposedBlock':
            obj_ = ComposedBlockType.factory(parent_object_=self)
            obj_.build(child_)
            self.ComposedBlock.append(obj_)
            obj_.original_tagname_ = 'ComposedBlock'
# end class PageSpaceType


class ShapeType(GeneratedsSuper):
    """Describes the bounding shape of a block, if it is not rectangular."""
    subclass = None
    superclass = None
    def __init__(self, Polygon=None, Ellipse=None, Circle=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Polygon = Polygon
        self.Ellipse = Ellipse
        self.Circle = Circle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeType.subclass:
            return ShapeType.subclass(*args_, **kwargs_)
        else:
            return ShapeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Polygon(self):
        return self.Polygon
    def set_Polygon(self, Polygon):
        self.Polygon = Polygon
    def get_Ellipse(self):
        return self.Ellipse
    def set_Ellipse(self, Ellipse):
        self.Ellipse = Ellipse
    def get_Circle(self):
        return self.Circle
    def set_Circle(self, Circle):
        self.Circle = Circle
    def hasContent_(self):
        if (
            self.Polygon is not None or
            self.Ellipse is not None or
            self.Circle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Polygon is not None:
            self.Polygon.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Polygon', pretty_print=pretty_print)
        if self.Ellipse is not None:
            self.Ellipse.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Ellipse', pretty_print=pretty_print)
        if self.Circle is not None:
            self.Circle.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Circle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Polygon':
            obj_ = PolygonType.factory(parent_object_=self)
            obj_.build(child_)
            self.Polygon = obj_
            obj_.original_tagname_ = 'Polygon'
        elif nodeName_ == 'Ellipse':
            obj_ = EllipseType.factory(parent_object_=self)
            obj_.build(child_)
            self.Ellipse = obj_
            obj_.original_tagname_ = 'Ellipse'
        elif nodeName_ == 'Circle':
            obj_ = CircleType.factory(parent_object_=self)
            obj_.build(child_)
            self.Circle = obj_
            obj_.original_tagname_ = 'Circle'
# end class ShapeType


class PolygonType(GeneratedsSuper):
    """A polygon shape."""
    subclass = None
    superclass = None
    def __init__(self, POINTS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.POINTS = _cast(None, POINTS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolygonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolygonType.subclass:
            return PolygonType.subclass(*args_, **kwargs_)
        else:
            return PolygonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_POINTS(self):
        return self.POINTS
    def set_POINTS(self, POINTS):
        self.POINTS = POINTS
    def validate_PointsType(self, value):
        # Validate type PointsType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolygonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolygonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolygonType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PolygonType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PolygonType'):
        if self.POINTS is not None and 'POINTS' not in already_processed:
            already_processed.add('POINTS')
            outfile.write(' POINTS=%s' % (quote_attrib(self.POINTS), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolygonType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('POINTS', node)
        if value is not None and 'POINTS' not in already_processed:
            already_processed.add('POINTS')
            self.POINTS = value
            self.validate_PointsType(self.POINTS)    # validate type PointsType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PolygonType


class EllipseType(GeneratedsSuper):
    """An ellipse shape. HPOS and VPOS describe the center of the ellipse.
    HLENGTH and VLENGTH are the width and height of the described
    ellipse.The attribute ROTATION tells the rotation of the e.g.
    text or illustration within the block. The value is in degrees
    counterclockwise."""
    subclass = None
    superclass = None
    def __init__(self, HPOS=None, VPOS=None, HLENGTH=None, VLENGTH=None, ROTATION=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
        self.HLENGTH = _cast(float, HLENGTH)
        self.VLENGTH = _cast(float, VLENGTH)
        self.ROTATION = _cast(float, ROTATION)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EllipseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipseType.subclass:
            return EllipseType.subclass(*args_, **kwargs_)
        else:
            return EllipseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def get_HLENGTH(self):
        return self.HLENGTH
    def set_HLENGTH(self, HLENGTH):
        self.HLENGTH = HLENGTH
    def get_VLENGTH(self):
        return self.VLENGTH
    def set_VLENGTH(self, VLENGTH):
        self.VLENGTH = VLENGTH
    def get_ROTATION(self):
        return self.ROTATION
    def set_ROTATION(self, ROTATION):
        self.ROTATION = ROTATION
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EllipseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EllipseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EllipseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EllipseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EllipseType'):
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
        if self.HLENGTH is not None and 'HLENGTH' not in already_processed:
            already_processed.add('HLENGTH')
            outfile.write(' HLENGTH="%s"' % self.gds_format_float(self.HLENGTH, input_name='HLENGTH'))
        if self.VLENGTH is not None and 'VLENGTH' not in already_processed:
            already_processed.add('VLENGTH')
            outfile.write(' VLENGTH="%s"' % self.gds_format_float(self.VLENGTH, input_name='VLENGTH'))
        if self.ROTATION is not None and 'ROTATION' not in already_processed:
            already_processed.add('ROTATION')
            outfile.write(' ROTATION="%s"' % self.gds_format_float(self.ROTATION, input_name='ROTATION'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EllipseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
        value = find_attr_value_('HLENGTH', node)
        if value is not None and 'HLENGTH' not in already_processed:
            already_processed.add('HLENGTH')
            try:
                self.HLENGTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HLENGTH): %s' % exp)
        value = find_attr_value_('VLENGTH', node)
        if value is not None and 'VLENGTH' not in already_processed:
            already_processed.add('VLENGTH')
            try:
                self.VLENGTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VLENGTH): %s' % exp)
        value = find_attr_value_('ROTATION', node)
        if value is not None and 'ROTATION' not in already_processed:
            already_processed.add('ROTATION')
            try:
                self.ROTATION = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ROTATION): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EllipseType


class CircleType(GeneratedsSuper):
    """A circle shape. HPOS and VPOS describe the center of the circle."""
    subclass = None
    superclass = None
    def __init__(self, HPOS=None, VPOS=None, RADIUS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
        self.RADIUS = _cast(float, RADIUS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CircleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CircleType.subclass:
            return CircleType.subclass(*args_, **kwargs_)
        else:
            return CircleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def get_RADIUS(self):
        return self.RADIUS
    def set_RADIUS(self, RADIUS):
        self.RADIUS = RADIUS
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CircleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CircleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CircleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CircleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CircleType'):
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
        if self.RADIUS is not None and 'RADIUS' not in already_processed:
            already_processed.add('RADIUS')
            outfile.write(' RADIUS="%s"' % self.gds_format_float(self.RADIUS, input_name='RADIUS'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CircleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
        value = find_attr_value_('RADIUS', node)
        if value is not None and 'RADIUS' not in already_processed:
            already_processed.add('RADIUS')
            try:
                self.RADIUS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (RADIUS): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CircleType


class sourceImageInformationType(GeneratedsSuper):
    """Information to identify the image file from which the OCR text was
    created."""
    subclass = None
    superclass = None
    def __init__(self, fileName=None, fileIdentifier=None, documentIdentifier=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.fileName = fileName
        self.validate_fileNameType(self.fileName)
        if fileIdentifier is None:
            self.fileIdentifier = []
        else:
            self.fileIdentifier = fileIdentifier
        if documentIdentifier is None:
            self.documentIdentifier = []
        else:
            self.documentIdentifier = documentIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sourceImageInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sourceImageInformationType.subclass:
            return sourceImageInformationType.subclass(*args_, **kwargs_)
        else:
            return sourceImageInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileName(self):
        return self.fileName
    def set_fileName(self, fileName):
        self.fileName = fileName
    def get_fileIdentifier(self):
        return self.fileIdentifier
    def set_fileIdentifier(self, fileIdentifier):
        self.fileIdentifier = fileIdentifier
    def add_fileIdentifier(self, value):
        self.fileIdentifier.append(value)
    def add_fileIdentifier(self, value):
        self.fileIdentifier.append(value)
    def insert_fileIdentifier_at(self, index, value):
        self.fileIdentifier.insert(index, value)
    def replace_fileIdentifier_at(self, index, value):
        self.fileIdentifier[index] = value
    def get_documentIdentifier(self):
        return self.documentIdentifier
    def set_documentIdentifier(self, documentIdentifier):
        self.documentIdentifier = documentIdentifier
    def add_documentIdentifier(self, value):
        self.documentIdentifier.append(value)
    def add_documentIdentifier(self, value):
        self.documentIdentifier.append(value)
    def insert_documentIdentifier_at(self, index, value):
        self.documentIdentifier.insert(index, value)
    def replace_documentIdentifier_at(self, index, value):
        self.documentIdentifier[index] = value
    def validate_fileNameType(self, value):
        # Validate type fileNameType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.fileName is not None or
            self.fileIdentifier or
            self.documentIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sourceImageInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sourceImageInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sourceImageInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sourceImageInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sourceImageInformationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sourceImageInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fileName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfileName>%s</%sfileName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fileName), input_name='fileName')), namespaceprefix_ , eol_))
        for fileIdentifier_ in self.fileIdentifier:
            fileIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileIdentifier', pretty_print=pretty_print)
        for documentIdentifier_ in self.documentIdentifier:
            documentIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='documentIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileName':
            fileName_ = child_.text
            fileName_ = self.gds_validate_string(fileName_, node, 'fileName')
            self.fileName = fileName_
            # validate type fileNameType
            self.validate_fileNameType(self.fileName)
        elif nodeName_ == 'fileIdentifier':
            obj_ = fileIdentifierType.factory(parent_object_=self)
            obj_.build(child_)
            self.fileIdentifier.append(obj_)
            obj_.original_tagname_ = 'fileIdentifier'
        elif nodeName_ == 'documentIdentifier':
            obj_ = documentIdentifierType.factory(parent_object_=self)
            obj_.build(child_)
            self.documentIdentifier.append(obj_)
            obj_.original_tagname_ = 'documentIdentifier'
# end class sourceImageInformationType


class fileIdentifierType(GeneratedsSuper):
    """A unique identifier for the image file. This is drawn from MIX. This
    identifier must be unique within the local system. To facilitate
    file sharing or interoperability with other systems,
    fileIdentifierLocation may be added to designate the system or
    application where the identifier is unique.A location qualifier,
    i.e., a namespace."""
    subclass = None
    superclass = None
    def __init__(self, fileIdentifierLocation=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.fileIdentifierLocation = _cast(None, fileIdentifierLocation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileIdentifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileIdentifierType.subclass:
            return fileIdentifierType.subclass(*args_, **kwargs_)
        else:
            return fileIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileIdentifierLocation(self):
        return self.fileIdentifierLocation
    def set_fileIdentifierLocation(self, fileIdentifierLocation):
        self.fileIdentifierLocation = fileIdentifierLocation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_fileIdentifierLocationValueType(self, value):
        # Validate type fileIdentifierLocationValueType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fileIdentifierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileIdentifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileIdentifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileIdentifierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileIdentifierType'):
        if self.fileIdentifierLocation is not None and 'fileIdentifierLocation' not in already_processed:
            already_processed.add('fileIdentifierLocation')
            outfile.write(' fileIdentifierLocation=%s' % (quote_attrib(self.fileIdentifierLocation), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fileIdentifierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileIdentifierLocation', node)
        if value is not None and 'fileIdentifierLocation' not in already_processed:
            already_processed.add('fileIdentifierLocation')
            self.fileIdentifierLocation = value
            self.validate_fileIdentifierLocationValueType(self.fileIdentifierLocation)    # validate type fileIdentifierLocationValueType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fileIdentifierType


class documentIdentifierType(GeneratedsSuper):
    """A unique identifier for the document. This identifier must be unique
    within the local system. To facilitate file sharing or
    interoperability with other systems, documentIdentifierLocation
    may be added to designate the system or application where the
    identifier is unique.A location qualifier, i.e., a namespace."""
    subclass = None
    superclass = None
    def __init__(self, documentIdentifierLocation=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.documentIdentifierLocation = _cast(None, documentIdentifierLocation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, documentIdentifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if documentIdentifierType.subclass:
            return documentIdentifierType.subclass(*args_, **kwargs_)
        else:
            return documentIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_documentIdentifierLocation(self):
        return self.documentIdentifierLocation
    def set_documentIdentifierLocation(self, documentIdentifierLocation):
        self.documentIdentifierLocation = documentIdentifierLocation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_documentIdentifierLocationValueType(self, value):
        # Validate type documentIdentifierLocationValueType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='documentIdentifierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('documentIdentifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='documentIdentifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='documentIdentifierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='documentIdentifierType'):
        if self.documentIdentifierLocation is not None and 'documentIdentifierLocation' not in already_processed:
            already_processed.add('documentIdentifierLocation')
            outfile.write(' documentIdentifierLocation=%s' % (quote_attrib(self.documentIdentifierLocation), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='documentIdentifierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('documentIdentifierLocation', node)
        if value is not None and 'documentIdentifierLocation' not in already_processed:
            already_processed.add('documentIdentifierLocation')
            self.documentIdentifierLocation = value
            self.validate_documentIdentifierLocationValueType(self.documentIdentifierLocation)    # validate type documentIdentifierLocationValueType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class documentIdentifierType


class ocrProcessingType(GeneratedsSuper):
    """Deprecated. processingType should be used instead.Information on how
    the text was created, including preprocessing, OCR processing,
    and postprocessing steps. Where possible, this draws from MIX's
    change history."""
    subclass = None
    superclass = None
    def __init__(self, preProcessingStep=None, ocrProcessingStep=None, postProcessingStep=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if preProcessingStep is None:
            self.preProcessingStep = []
        else:
            self.preProcessingStep = preProcessingStep
        self.ocrProcessingStep = ocrProcessingStep
        if postProcessingStep is None:
            self.postProcessingStep = []
        else:
            self.postProcessingStep = postProcessingStep
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ocrProcessingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ocrProcessingType.subclass:
            return ocrProcessingType.subclass(*args_, **kwargs_)
        else:
            return ocrProcessingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_preProcessingStep(self):
        return self.preProcessingStep
    def set_preProcessingStep(self, preProcessingStep):
        self.preProcessingStep = preProcessingStep
    def add_preProcessingStep(self, value):
        self.preProcessingStep.append(value)
    def add_preProcessingStep(self, value):
        self.preProcessingStep.append(value)
    def insert_preProcessingStep_at(self, index, value):
        self.preProcessingStep.insert(index, value)
    def replace_preProcessingStep_at(self, index, value):
        self.preProcessingStep[index] = value
    def get_ocrProcessingStep(self):
        return self.ocrProcessingStep
    def set_ocrProcessingStep(self, ocrProcessingStep):
        self.ocrProcessingStep = ocrProcessingStep
    def get_postProcessingStep(self):
        return self.postProcessingStep
    def set_postProcessingStep(self, postProcessingStep):
        self.postProcessingStep = postProcessingStep
    def add_postProcessingStep(self, value):
        self.postProcessingStep.append(value)
    def add_postProcessingStep(self, value):
        self.postProcessingStep.append(value)
    def insert_postProcessingStep_at(self, index, value):
        self.postProcessingStep.insert(index, value)
    def replace_postProcessingStep_at(self, index, value):
        self.postProcessingStep[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.preProcessingStep or
            self.ocrProcessingStep is not None or
            self.postProcessingStep
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ocrProcessingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ocrProcessingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ocrProcessingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ocrProcessingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ocrProcessingType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ocrProcessingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for preProcessingStep_ in self.preProcessingStep:
            preProcessingStep_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preProcessingStep', pretty_print=pretty_print)
        if self.ocrProcessingStep is not None:
            self.ocrProcessingStep.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ocrProcessingStep', pretty_print=pretty_print)
        for postProcessingStep_ in self.postProcessingStep:
            postProcessingStep_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='postProcessingStep', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'preProcessingStep':
            class_obj_ = self.get_class_obj_(child_, processingStepType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.preProcessingStep.append(obj_)
            obj_.original_tagname_ = 'preProcessingStep'
        elif nodeName_ == 'ocrProcessingStep':
            class_obj_ = self.get_class_obj_(child_, processingStepType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.ocrProcessingStep = obj_
            obj_.original_tagname_ = 'ocrProcessingStep'
        elif nodeName_ == 'postProcessingStep':
            class_obj_ = self.get_class_obj_(child_, processingStepType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.postProcessingStep.append(obj_)
            obj_.original_tagname_ = 'postProcessingStep'
# end class ocrProcessingType


class processingStepType(GeneratedsSuper):
    """Description of the processing step."""
    subclass = None
    superclass = None
    def __init__(self, processingCategory=None, processingDateTime=None, processingAgency=None, processingStepDescription=None, processingStepSettings=None, processingSoftware=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.processingCategory = processingCategory
        self.validate_processingCategoryType(self.processingCategory)
        self.processingDateTime = processingDateTime
        self.validate_dateTimeType(self.processingDateTime)
        self.processingAgency = processingAgency
        if processingStepDescription is None:
            self.processingStepDescription = []
        else:
            self.processingStepDescription = processingStepDescription
        self.processingStepSettings = processingStepSettings
        self.processingSoftware = processingSoftware
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, processingStepType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if processingStepType.subclass:
            return processingStepType.subclass(*args_, **kwargs_)
        else:
            return processingStepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processingCategory(self):
        return self.processingCategory
    def set_processingCategory(self, processingCategory):
        self.processingCategory = processingCategory
    def get_processingDateTime(self):
        return self.processingDateTime
    def set_processingDateTime(self, processingDateTime):
        self.processingDateTime = processingDateTime
    def get_processingAgency(self):
        return self.processingAgency
    def set_processingAgency(self, processingAgency):
        self.processingAgency = processingAgency
    def get_processingStepDescription(self):
        return self.processingStepDescription
    def set_processingStepDescription(self, processingStepDescription):
        self.processingStepDescription = processingStepDescription
    def add_processingStepDescription(self, value):
        self.processingStepDescription.append(value)
    def add_processingStepDescription(self, value):
        self.processingStepDescription.append(value)
    def insert_processingStepDescription_at(self, index, value):
        self.processingStepDescription.insert(index, value)
    def replace_processingStepDescription_at(self, index, value):
        self.processingStepDescription[index] = value
    def get_processingStepSettings(self):
        return self.processingStepSettings
    def set_processingStepSettings(self, processingStepSettings):
        self.processingStepSettings = processingStepSettings
    def get_processingSoftware(self):
        return self.processingSoftware
    def set_processingSoftware(self, processingSoftware):
        self.processingSoftware = processingSoftware
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_processingCategoryType(self, value):
        # Validate type processingCategoryType, a restriction on xsd:string.
        pass
    def validate_dateTimeType(self, value):
        # Validate type dateTimeType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.processingCategory is not None or
            self.processingDateTime is not None or
            self.processingAgency is not None or
            self.processingStepDescription or
            self.processingStepSettings is not None or
            self.processingSoftware is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='processingStepType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('processingStepType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='processingStepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='processingStepType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='processingStepType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='processingStepType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processingCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocessingCategory>%s</%sprocessingCategory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.processingCategory)), input_name='processingCategory')), namespaceprefix_ , eol_))
        if self.processingDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocessingDateTime>%s</%sprocessingDateTime>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.processingDateTime), input_name='processingDateTime')), namespaceprefix_ , eol_))
        if self.processingAgency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocessingAgency>%s</%sprocessingAgency>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.processingAgency), input_name='processingAgency')), namespaceprefix_ , eol_))
        for processingStepDescription_ in self.processingStepDescription:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocessingStepDescription>%s</%sprocessingStepDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(processingStepDescription_), input_name='processingStepDescription')), namespaceprefix_ , eol_))
        if self.processingStepSettings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocessingStepSettings>%s</%sprocessingStepSettings>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.processingStepSettings), input_name='processingStepSettings')), namespaceprefix_ , eol_))
        if self.processingSoftware is not None:
            self.processingSoftware.export(outfile, level, namespaceprefix_, namespacedef_='', name_='processingSoftware', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processingCategory':
            processingCategory_ = child_.text
            self.processingCategory = processingCategory_
            # validate type processingCategoryType
            self.validate_processingCategoryType(self.processingCategory)
        elif nodeName_ == 'processingDateTime':
            processingDateTime_ = child_.text
            processingDateTime_ = self.gds_validate_string(processingDateTime_, node, 'processingDateTime')
            self.processingDateTime = processingDateTime_
            # validate type dateTimeType
            self.validate_dateTimeType(self.processingDateTime)
        elif nodeName_ == 'processingAgency':
            processingAgency_ = child_.text
            processingAgency_ = self.gds_validate_string(processingAgency_, node, 'processingAgency')
            self.processingAgency = processingAgency_
        elif nodeName_ == 'processingStepDescription':
            processingStepDescription_ = child_.text
            processingStepDescription_ = self.gds_validate_string(processingStepDescription_, node, 'processingStepDescription')
            self.processingStepDescription.append(processingStepDescription_)
        elif nodeName_ == 'processingStepSettings':
            processingStepSettings_ = child_.text
            processingStepSettings_ = self.gds_validate_string(processingStepSettings_, node, 'processingStepSettings')
            self.processingStepSettings = processingStepSettings_
        elif nodeName_ == 'processingSoftware':
            obj_ = processingSoftwareType.factory(parent_object_=self)
            obj_.build(child_)
            self.processingSoftware = obj_
            obj_.original_tagname_ = 'processingSoftware'
# end class processingStepType


class processingSoftwareType(GeneratedsSuper):
    """Information about a software application. Where applicable, the
    preferred method for determining this information is by
    selecting Help -- About."""
    subclass = None
    superclass = None
    def __init__(self, softwareCreator=None, softwareName=None, softwareVersion=None, applicationDescription=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.softwareCreator = softwareCreator
        self.softwareName = softwareName
        self.softwareVersion = softwareVersion
        self.applicationDescription = applicationDescription
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, processingSoftwareType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if processingSoftwareType.subclass:
            return processingSoftwareType.subclass(*args_, **kwargs_)
        else:
            return processingSoftwareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_softwareCreator(self):
        return self.softwareCreator
    def set_softwareCreator(self, softwareCreator):
        self.softwareCreator = softwareCreator
    def get_softwareName(self):
        return self.softwareName
    def set_softwareName(self, softwareName):
        self.softwareName = softwareName
    def get_softwareVersion(self):
        return self.softwareVersion
    def set_softwareVersion(self, softwareVersion):
        self.softwareVersion = softwareVersion
    def get_applicationDescription(self):
        return self.applicationDescription
    def set_applicationDescription(self, applicationDescription):
        self.applicationDescription = applicationDescription
    def hasContent_(self):
        if (
            self.softwareCreator is not None or
            self.softwareName is not None or
            self.softwareVersion is not None or
            self.applicationDescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='processingSoftwareType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('processingSoftwareType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='processingSoftwareType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='processingSoftwareType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='processingSoftwareType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='processingSoftwareType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.softwareCreator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareCreator>%s</%ssoftwareCreator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareCreator), input_name='softwareCreator')), namespaceprefix_ , eol_))
        if self.softwareName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareName>%s</%ssoftwareName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareName), input_name='softwareName')), namespaceprefix_ , eol_))
        if self.softwareVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareVersion>%s</%ssoftwareVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareVersion), input_name='softwareVersion')), namespaceprefix_ , eol_))
        if self.applicationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicationDescription>%s</%sapplicationDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.applicationDescription), input_name='applicationDescription')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'softwareCreator':
            softwareCreator_ = child_.text
            softwareCreator_ = self.gds_validate_string(softwareCreator_, node, 'softwareCreator')
            self.softwareCreator = softwareCreator_
        elif nodeName_ == 'softwareName':
            softwareName_ = child_.text
            softwareName_ = self.gds_validate_string(softwareName_, node, 'softwareName')
            self.softwareName = softwareName_
        elif nodeName_ == 'softwareVersion':
            softwareVersion_ = child_.text
            softwareVersion_ = self.gds_validate_string(softwareVersion_, node, 'softwareVersion')
            self.softwareVersion = softwareVersion_
        elif nodeName_ == 'applicationDescription':
            applicationDescription_ = child_.text
            applicationDescription_ = self.gds_validate_string(applicationDescription_, node, 'applicationDescription')
            self.applicationDescription = applicationDescription_
# end class processingSoftwareType


class ComposedBlockType(BlockType):
    """A block that consists of other blocksA user defined string to
    identify the type of composed block (e.g. table, advertisement,
    ...)An ID to link to an image which contains only the composed
    block. The ID and the file link is defined in the related METS
    file."""
    subclass = None
    superclass = BlockType
    def __init__(self, ID=None, STYLEREFS=None, TAGREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, ROTATION=None, IDNEXT=None, CS=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, Shape=None, TYPE=None, FILEID=None, TextBlock=None, Illustration=None, GraphicalElement=None, ComposedBlock=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ComposedBlockType, self).__init__(ID, STYLEREFS, TAGREFS, PROCESSINGREFS, HEIGHT, WIDTH, HPOS, VPOS, ROTATION, IDNEXT, CS, type_, href, role, arcrole, title, show, actuate, Shape,  **kwargs_)
        self.TYPE = _cast(None, TYPE)
        self.FILEID = _cast(None, FILEID)
        if TextBlock is None:
            self.TextBlock = []
        else:
            self.TextBlock = TextBlock
        if Illustration is None:
            self.Illustration = []
        else:
            self.Illustration = Illustration
        if GraphicalElement is None:
            self.GraphicalElement = []
        else:
            self.GraphicalElement = GraphicalElement
        if ComposedBlock is None:
            self.ComposedBlock = []
        else:
            self.ComposedBlock = ComposedBlock
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComposedBlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComposedBlockType.subclass:
            return ComposedBlockType.subclass(*args_, **kwargs_)
        else:
            return ComposedBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextBlock(self):
        return self.TextBlock
    def set_TextBlock(self, TextBlock):
        self.TextBlock = TextBlock
    def add_TextBlock(self, value):
        self.TextBlock.append(value)
    def add_TextBlock(self, value):
        self.TextBlock.append(value)
    def insert_TextBlock_at(self, index, value):
        self.TextBlock.insert(index, value)
    def replace_TextBlock_at(self, index, value):
        self.TextBlock[index] = value
    def get_Illustration(self):
        return self.Illustration
    def set_Illustration(self, Illustration):
        self.Illustration = Illustration
    def add_Illustration(self, value):
        self.Illustration.append(value)
    def add_Illustration(self, value):
        self.Illustration.append(value)
    def insert_Illustration_at(self, index, value):
        self.Illustration.insert(index, value)
    def replace_Illustration_at(self, index, value):
        self.Illustration[index] = value
    def get_GraphicalElement(self):
        return self.GraphicalElement
    def set_GraphicalElement(self, GraphicalElement):
        self.GraphicalElement = GraphicalElement
    def add_GraphicalElement(self, value):
        self.GraphicalElement.append(value)
    def add_GraphicalElement(self, value):
        self.GraphicalElement.append(value)
    def insert_GraphicalElement_at(self, index, value):
        self.GraphicalElement.insert(index, value)
    def replace_GraphicalElement_at(self, index, value):
        self.GraphicalElement[index] = value
    def get_ComposedBlock(self):
        return self.ComposedBlock
    def set_ComposedBlock(self, ComposedBlock):
        self.ComposedBlock = ComposedBlock
    def add_ComposedBlock(self, value):
        self.ComposedBlock.append(value)
    def add_ComposedBlock(self, value):
        self.ComposedBlock.append(value)
    def insert_ComposedBlock_at(self, index, value):
        self.ComposedBlock.insert(index, value)
    def replace_ComposedBlock_at(self, index, value):
        self.ComposedBlock[index] = value
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_FILEID(self):
        return self.FILEID
    def set_FILEID(self, FILEID):
        self.FILEID = FILEID
    def hasContent_(self):
        if (
            self.TextBlock or
            self.Illustration or
            self.GraphicalElement or
            self.ComposedBlock or
            super(ComposedBlockType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComposedBlockType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComposedBlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComposedBlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComposedBlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComposedBlockType'):
        super(ComposedBlockType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComposedBlockType')
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.FILEID is not None and 'FILEID' not in already_processed:
            already_processed.add('FILEID')
            outfile.write(' FILEID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FILEID), input_name='FILEID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComposedBlockType', fromsubclass_=False, pretty_print=True):
        super(ComposedBlockType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TextBlock_ in self.TextBlock:
            TextBlock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextBlock', pretty_print=pretty_print)
        for Illustration_ in self.Illustration:
            Illustration_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Illustration', pretty_print=pretty_print)
        for GraphicalElement_ in self.GraphicalElement:
            GraphicalElement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GraphicalElement', pretty_print=pretty_print)
        for ComposedBlock_ in self.ComposedBlock:
            ComposedBlock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComposedBlock', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('FILEID', node)
        if value is not None and 'FILEID' not in already_processed:
            already_processed.add('FILEID')
            self.FILEID = value
        super(ComposedBlockType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextBlock':
            obj_ = TextBlockType.factory(parent_object_=self)
            obj_.build(child_)
            self.TextBlock.append(obj_)
            obj_.original_tagname_ = 'TextBlock'
        elif nodeName_ == 'Illustration':
            obj_ = IllustrationType.factory(parent_object_=self)
            obj_.build(child_)
            self.Illustration.append(obj_)
            obj_.original_tagname_ = 'Illustration'
        elif nodeName_ == 'GraphicalElement':
            obj_ = GraphicalElementType.factory(parent_object_=self)
            obj_.build(child_)
            self.GraphicalElement.append(obj_)
            obj_.original_tagname_ = 'GraphicalElement'
        elif nodeName_ == 'ComposedBlock':
            obj_ = ComposedBlockType.factory(parent_object_=self)
            obj_.build(child_)
            self.ComposedBlock.append(obj_)
            obj_.original_tagname_ = 'ComposedBlock'
        super(ComposedBlockType, self).buildChildren(child_, node, nodeName_, True)
# end class ComposedBlockType


class IllustrationType(BlockType):
    """A picture or image.A user defined string to identify the type of
    illustration like photo, map, drawing, chart, ...A link to an
    image which contains only the illustration."""
    subclass = None
    superclass = BlockType
    def __init__(self, ID=None, STYLEREFS=None, TAGREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, ROTATION=None, IDNEXT=None, CS=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, Shape=None, TYPE=None, FILEID=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(IllustrationType, self).__init__(ID, STYLEREFS, TAGREFS, PROCESSINGREFS, HEIGHT, WIDTH, HPOS, VPOS, ROTATION, IDNEXT, CS, type_, href, role, arcrole, title, show, actuate, Shape,  **kwargs_)
        self.TYPE = _cast(None, TYPE)
        self.FILEID = _cast(None, FILEID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IllustrationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IllustrationType.subclass:
            return IllustrationType.subclass(*args_, **kwargs_)
        else:
            return IllustrationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_FILEID(self):
        return self.FILEID
    def set_FILEID(self, FILEID):
        self.FILEID = FILEID
    def hasContent_(self):
        if (
            super(IllustrationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IllustrationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IllustrationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IllustrationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IllustrationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IllustrationType'):
        super(IllustrationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IllustrationType')
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.FILEID is not None and 'FILEID' not in already_processed:
            already_processed.add('FILEID')
            outfile.write(' FILEID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FILEID), input_name='FILEID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IllustrationType', fromsubclass_=False, pretty_print=True):
        super(IllustrationType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('FILEID', node)
        if value is not None and 'FILEID' not in already_processed:
            already_processed.add('FILEID')
            self.FILEID = value
        super(IllustrationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IllustrationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IllustrationType


class GraphicalElementType(BlockType):
    """A graphic used to separate blocks. Usually a line or rectangle."""
    subclass = None
    superclass = BlockType
    def __init__(self, ID=None, STYLEREFS=None, TAGREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, ROTATION=None, IDNEXT=None, CS=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, Shape=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GraphicalElementType, self).__init__(ID, STYLEREFS, TAGREFS, PROCESSINGREFS, HEIGHT, WIDTH, HPOS, VPOS, ROTATION, IDNEXT, CS, type_, href, role, arcrole, title, show, actuate, Shape,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GraphicalElementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GraphicalElementType.subclass:
            return GraphicalElementType.subclass(*args_, **kwargs_)
        else:
            return GraphicalElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GraphicalElementType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GraphicalElementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GraphicalElementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GraphicalElementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GraphicalElementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GraphicalElementType'):
        super(GraphicalElementType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GraphicalElementType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GraphicalElementType', fromsubclass_=False, pretty_print=True):
        super(GraphicalElementType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GraphicalElementType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GraphicalElementType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GraphicalElementType


class TextBlockType(BlockType):
    """A block of text.Attribute deprecated. LANG should be used
    instead.Attribute to record language of the textblock."""
    subclass = None
    superclass = BlockType
    def __init__(self, ID=None, STYLEREFS=None, TAGREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, ROTATION=None, IDNEXT=None, CS=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, Shape=None, language=None, LANG=None, TextLine=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(TextBlockType, self).__init__(ID, STYLEREFS, TAGREFS, PROCESSINGREFS, HEIGHT, WIDTH, HPOS, VPOS, ROTATION, IDNEXT, CS, type_, href, role, arcrole, title, show, actuate, Shape,  **kwargs_)
        self.language = _cast(None, language)
        self.LANG = _cast(None, LANG)
        if TextLine is None:
            self.TextLine = []
        else:
            self.TextLine = TextLine
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextBlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextBlockType.subclass:
            return TextBlockType.subclass(*args_, **kwargs_)
        else:
            return TextBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextLine(self):
        return self.TextLine
    def set_TextLine(self, TextLine):
        self.TextLine = TextLine
    def add_TextLine(self, value):
        self.TextLine.append(value)
    def add_TextLine(self, value):
        self.TextLine.append(value)
    def insert_TextLine_at(self, index, value):
        self.TextLine.insert(index, value)
    def replace_TextLine_at(self, index, value):
        self.TextLine[index] = value
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_LANG(self):
        return self.LANG
    def set_LANG(self, LANG):
        self.LANG = LANG
    def hasContent_(self):
        if (
            self.TextLine or
            super(TextBlockType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextBlockType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextBlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextBlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextBlockType'):
        super(TextBlockType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBlockType')
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.LANG is not None and 'LANG' not in already_processed:
            already_processed.add('LANG')
            outfile.write(' LANG=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG), input_name='LANG')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextBlockType', fromsubclass_=False, pretty_print=True):
        super(TextBlockType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TextLine_ in self.TextLine:
            TextLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextLine', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('LANG', node)
        if value is not None and 'LANG' not in already_processed:
            already_processed.add('LANG')
            self.LANG = value
        super(TextBlockType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextLine':
            obj_ = TextLineType.factory(parent_object_=self)
            obj_.build(child_)
            self.TextLine.append(obj_)
            obj_.original_tagname_ = 'TextLine'
        super(TextBlockType, self).buildChildren(child_, node, nodeName_, True)
# end class TextBlockType


class TagType(GeneratedsSuper):
    """Type can be used to classify and group the information within each
    tag element type.Content / information value of the
    tag.Description text for tag information for clarification.Any
    URI for authority or description relevant information."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, TYPE=None, LABEL=None, DESCRIPTION=None, URI=None, XmlData=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.TYPE = _cast(None, TYPE)
        self.LABEL = _cast(None, LABEL)
        self.DESCRIPTION = _cast(None, DESCRIPTION)
        self.URI = _cast(None, URI)
        self.XmlData = XmlData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TagType.subclass:
            return TagType.subclass(*args_, **kwargs_)
        else:
            return TagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XmlData(self):
        return self.XmlData
    def set_XmlData(self, XmlData):
        self.XmlData = XmlData
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_URI(self):
        return self.URI
    def set_URI(self, URI):
        self.URI = URI
    def hasContent_(self):
        if (
            self.XmlData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TagType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TagType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
        if self.DESCRIPTION is not None and 'DESCRIPTION' not in already_processed:
            already_processed.add('DESCRIPTION')
            outfile.write(' DESCRIPTION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DESCRIPTION), input_name='DESCRIPTION')), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.URI), input_name='URI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.XmlData is not None:
            self.XmlData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XmlData', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        value = find_attr_value_('DESCRIPTION', node)
        if value is not None and 'DESCRIPTION' not in already_processed:
            already_processed.add('DESCRIPTION')
            self.DESCRIPTION = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XmlData':
            obj_ = XmlDataType.factory(parent_object_=self)
            obj_.build(child_)
            self.XmlData = obj_
            obj_.original_tagname_ = 'XmlData'
# end class TagType


class GlyphType(GeneratedsSuper):
    """Modern OCR software stores information on glyph level. A glyph is
    essentially a character or ligature. Accordingly the value for
    the glyph element will be defined as follows: Pre-composed
    representation = base + combining character(s) (decomposed
    representation) See
    http://www.fileformat.info/info/unicode/char/0101/index.htm
    "U+0101" = (U+0061) + (U+0304) "combining characters" ("base
    characters" in combination with non-spacing marks or characters
    which are combined to one) are represented as one "glyph", e.g.
    áàâ. Each glyph has its own coordinate information and must be
    separately addressable as a distinct object. Correction and
    verification processes can be carried out for individual
    characters. Post-OCR analysis of the text as well as adaptive
    OCR algorithm must be able to record information on glyph level.
    In order to reproduce the decision of the OCR software, optional
    characters must be recorded. These are called variants. The OCR
    software evaluates each variant and picks the one with the
    highest confidence score as the glyph. The confidence score
    expresses how confident the OCR software is that a single glyph
    had been recognized correctly. The glyph elements are in order
    of the word. Each glyph need to be recorded to built up the
    whole word sequence. The glyph’s CONTENT attribute is no
    replacement for the string’s CONTENT attribute. Due to post-
    processing steps such as correction the values of both
    attributes may be inconsistent. CONTENT contains the precomposed
    representation (combining character) of the character from the
    parent String element. The sequence position of the Gylph
    element matches the position of the character in the String.
    This GC attribute records a float value between 0.0 and 1.0 that
    expresses the level of confidence for the variant where is 1 is
    certain. This attribute is optional. If it is not available, the
    default value for the variant is “0”. The GC attribute semantic
    is the same as the WC attribute on the String element and VC on
    Variant element."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, CONTENT=None, GC=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, Shape=None, Variant=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.CONTENT = _cast(None, CONTENT)
        self.GC = _cast(float, GC)
        self.HEIGHT = _cast(float, HEIGHT)
        self.WIDTH = _cast(float, WIDTH)
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
        self.Shape = Shape
        if Variant is None:
            self.Variant = []
        else:
            self.Variant = Variant
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlyphType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlyphType.subclass:
            return GlyphType.subclass(*args_, **kwargs_)
        else:
            return GlyphType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Shape(self):
        return self.Shape
    def set_Shape(self, Shape):
        self.Shape = Shape
    def get_Variant(self):
        return self.Variant
    def set_Variant(self, Variant):
        self.Variant = Variant
    def add_Variant(self, value):
        self.Variant.append(value)
    def add_Variant(self, value):
        self.Variant.append(value)
    def insert_Variant_at(self, index, value):
        self.Variant.insert(index, value)
    def replace_Variant_at(self, index, value):
        self.Variant[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_CONTENT(self):
        return self.CONTENT
    def set_CONTENT(self, CONTENT):
        self.CONTENT = CONTENT
    def get_GC(self):
        return self.GC
    def set_GC(self, GC):
        self.GC = GC
    def get_HEIGHT(self):
        return self.HEIGHT
    def set_HEIGHT(self, HEIGHT):
        self.HEIGHT = HEIGHT
    def get_WIDTH(self):
        return self.WIDTH
    def set_WIDTH(self, WIDTH):
        self.WIDTH = WIDTH
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def hasContent_(self):
        if (
            self.Shape is not None or
            self.Variant
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GlyphType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GlyphType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GlyphType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GlyphType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GlyphType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.CONTENT is not None and 'CONTENT' not in already_processed:
            already_processed.add('CONTENT')
            outfile.write(' CONTENT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONTENT), input_name='CONTENT')), ))
        if self.GC is not None and 'GC' not in already_processed:
            already_processed.add('GC')
            outfile.write(' GC="%s"' % self.gds_format_float(self.GC, input_name='GC'))
        if self.HEIGHT is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            outfile.write(' HEIGHT="%s"' % self.gds_format_float(self.HEIGHT, input_name='HEIGHT'))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH="%s"' % self.gds_format_float(self.WIDTH, input_name='WIDTH'))
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GlyphType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Shape is not None:
            self.Shape.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Shape', pretty_print=pretty_print)
        for Variant_ in self.Variant:
            Variant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Variant', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('CONTENT', node)
        if value is not None and 'CONTENT' not in already_processed:
            already_processed.add('CONTENT')
            self.CONTENT = value
        value = find_attr_value_('GC', node)
        if value is not None and 'GC' not in already_processed:
            already_processed.add('GC')
            try:
                self.GC = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (GC): %s' % exp)
        value = find_attr_value_('HEIGHT', node)
        if value is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            try:
                self.HEIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HEIGHT): %s' % exp)
        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            try:
                self.WIDTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WIDTH): %s' % exp)
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Shape':
            obj_ = ShapeType.factory(parent_object_=self)
            obj_.build(child_)
            self.Shape = obj_
            obj_.original_tagname_ = 'Shape'
        elif nodeName_ == 'Variant':
            obj_ = VariantType.factory(parent_object_=self)
            obj_.build(child_)
            self.Variant.append(obj_)
            obj_.original_tagname_ = 'Variant'
# end class GlyphType


class VariantType(GeneratedsSuper):
    """Alternative (combined) character for the glyph, outlined by OCR
    engine or similar recognition processes. In case the variant are
    two (combining) characters, two characters are outlined in one
    Variant element. E.g. a Glyph element with CONTENT="m" can have
    a Variant element with the content "rn". Details for different
    use-cases see on the samples on GitHub. Each Variant represents
    an option for the glyph that the OCR software detected as
    possible alternatives. In case the variant are two (combining)
    characters, two characters are outlined in one Variant element.
    E.g. a Glyph element with CONTENT="m" can have a Variant element
    with the content "rn". Details for different use-cases see on
    the samples on GitHub. This VC attribute records a float value
    between 0.0 and 1.0 that expresses the level of confidence for
    the variant where is 1 is certain. This attribute is optional.
    If it is not available, the default value for the variant is
    “0”. The VC attribute semantic is the same as the GC attribute
    on the Glyph element."""
    subclass = None
    superclass = None
    def __init__(self, CONTENT=None, VC=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CONTENT = _cast(None, CONTENT)
        self.VC = _cast(float, VC)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariantType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariantType.subclass:
            return VariantType.subclass(*args_, **kwargs_)
        else:
            return VariantType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CONTENT(self):
        return self.CONTENT
    def set_CONTENT(self, CONTENT):
        self.CONTENT = CONTENT
    def get_VC(self):
        return self.VC
    def set_VC(self, VC):
        self.VC = VC
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VariantType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariantType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariantType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariantType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VariantType'):
        if self.CONTENT is not None and 'CONTENT' not in already_processed:
            already_processed.add('CONTENT')
            outfile.write(' CONTENT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONTENT), input_name='CONTENT')), ))
        if self.VC is not None and 'VC' not in already_processed:
            already_processed.add('VC')
            outfile.write(' VC="%s"' % self.gds_format_float(self.VC, input_name='VC'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VariantType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CONTENT', node)
        if value is not None and 'CONTENT' not in already_processed:
            already_processed.add('CONTENT')
            self.CONTENT = value
        value = find_attr_value_('VC', node)
        if value is not None and 'VC' not in already_processed:
            already_processed.add('VC')
            try:
                self.VC = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VC): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VariantType


class OCRProcessingType(ocrProcessingType):
    subclass = None
    superclass = ocrProcessingType
    def __init__(self, preProcessingStep=None, ocrProcessingStep=None, postProcessingStep=None, ID=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OCRProcessingType, self).__init__(preProcessingStep, ocrProcessingStep, postProcessingStep,  **kwargs_)
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OCRProcessingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OCRProcessingType.subclass:
            return OCRProcessingType.subclass(*args_, **kwargs_)
        else:
            return OCRProcessingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def hasContent_(self):
        if (
            super(OCRProcessingType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OCRProcessingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OCRProcessingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OCRProcessingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OCRProcessingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OCRProcessingType'):
        super(OCRProcessingType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OCRProcessingType')
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OCRProcessingType', fromsubclass_=False, pretty_print=True):
        super(OCRProcessingType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        super(OCRProcessingType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OCRProcessingType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OCRProcessingType


class ProcessingType(processingStepType):
    subclass = None
    superclass = processingStepType
    def __init__(self, processingCategory=None, processingDateTime=None, processingAgency=None, processingStepDescription=None, processingStepSettings=None, processingSoftware=None, ID=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ProcessingType, self).__init__(processingCategory, processingDateTime, processingAgency, processingStepDescription, processingStepSettings, processingSoftware,  **kwargs_)
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessingType.subclass:
            return ProcessingType.subclass(*args_, **kwargs_)
        else:
            return ProcessingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def hasContent_(self):
        if (
            super(ProcessingType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProcessingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProcessingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProcessingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProcessingType'):
        super(ProcessingType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProcessingType')
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProcessingType', fromsubclass_=False, pretty_print=True):
        super(ProcessingType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        super(ProcessingType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProcessingType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProcessingType


class TextLineType(GeneratedsSuper):
    """Attribute to record language of the textline.Correction Status.
    Indicates whether manual correction has been done or not. The
    correction status should be recorded at the highest level
    possible (Block, TextLine, String)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, STYLEREFS=None, TAGREFS=None, PROCESSINGREFS=None, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, BASELINE=None, LANG=None, CS=None, Shape=None, String=None, SP=None, HYP=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.STYLEREFS = _cast(None, STYLEREFS)
        self.TAGREFS = _cast(None, TAGREFS)
        self.PROCESSINGREFS = _cast(None, PROCESSINGREFS)
        self.HEIGHT = _cast(float, HEIGHT)
        self.WIDTH = _cast(float, WIDTH)
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
        self.BASELINE = _cast(float, BASELINE)
        self.LANG = _cast(None, LANG)
        self.CS = _cast(bool, CS)
        self.Shape = Shape
        if String is None:
            self.String = []
        else:
            self.String = String
        if SP is None:
            self.SP = []
        else:
            self.SP = SP
        self.HYP = HYP
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextLineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextLineType.subclass:
            return TextLineType.subclass(*args_, **kwargs_)
        else:
            return TextLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Shape(self):
        return self.Shape
    def set_Shape(self, Shape):
        self.Shape = Shape
    def get_String(self):
        return self.String
    def set_String(self, String):
        self.String = String
    def add_String(self, value):
        self.String.append(value)
    def add_String(self, value):
        self.String.append(value)
    def insert_String_at(self, index, value):
        self.String.insert(index, value)
    def replace_String_at(self, index, value):
        self.String[index] = value
    def get_SP(self):
        return self.SP
    def set_SP(self, SP):
        self.SP = SP
    def add_SP(self, value):
        self.SP.append(value)
    def add_SP(self, value):
        self.SP.append(value)
    def insert_SP_at(self, index, value):
        self.SP.insert(index, value)
    def replace_SP_at(self, index, value):
        self.SP[index] = value
    def get_HYP(self):
        return self.HYP
    def set_HYP(self, HYP):
        self.HYP = HYP
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_STYLEREFS(self):
        return self.STYLEREFS
    def set_STYLEREFS(self, STYLEREFS):
        self.STYLEREFS = STYLEREFS
    def get_TAGREFS(self):
        return self.TAGREFS
    def set_TAGREFS(self, TAGREFS):
        self.TAGREFS = TAGREFS
    def get_PROCESSINGREFS(self):
        return self.PROCESSINGREFS
    def set_PROCESSINGREFS(self, PROCESSINGREFS):
        self.PROCESSINGREFS = PROCESSINGREFS
    def get_HEIGHT(self):
        return self.HEIGHT
    def set_HEIGHT(self, HEIGHT):
        self.HEIGHT = HEIGHT
    def get_WIDTH(self):
        return self.WIDTH
    def set_WIDTH(self, WIDTH):
        self.WIDTH = WIDTH
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def get_BASELINE(self):
        return self.BASELINE
    def set_BASELINE(self, BASELINE):
        self.BASELINE = BASELINE
    def get_LANG(self):
        return self.LANG
    def set_LANG(self, LANG):
        self.LANG = LANG
    def get_CS(self):
        return self.CS
    def set_CS(self, CS):
        self.CS = CS
    def validate_TextLineID(self, value):
        # Validate type TextLineID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Shape is not None or
            self.String or
            self.SP or
            self.HYP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextLineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextLineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextLineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextLineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextLineType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.STYLEREFS is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            outfile.write(' STYLEREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STYLEREFS), input_name='STYLEREFS')), ))
        if self.TAGREFS is not None and 'TAGREFS' not in already_processed:
            already_processed.add('TAGREFS')
            outfile.write(' TAGREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TAGREFS), input_name='TAGREFS')), ))
        if self.PROCESSINGREFS is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            outfile.write(' PROCESSINGREFS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PROCESSINGREFS), input_name='PROCESSINGREFS')), ))
        if self.HEIGHT is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            outfile.write(' HEIGHT="%s"' % self.gds_format_float(self.HEIGHT, input_name='HEIGHT'))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH="%s"' % self.gds_format_float(self.WIDTH, input_name='WIDTH'))
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
        if self.BASELINE is not None and 'BASELINE' not in already_processed:
            already_processed.add('BASELINE')
            outfile.write(' BASELINE="%s"' % self.gds_format_float(self.BASELINE, input_name='BASELINE'))
        if self.LANG is not None and 'LANG' not in already_processed:
            already_processed.add('LANG')
            outfile.write(' LANG=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG), input_name='LANG')), ))
        if self.CS is not None and 'CS' not in already_processed:
            already_processed.add('CS')
            outfile.write(' CS="%s"' % self.gds_format_boolean(self.CS, input_name='CS'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextLineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Shape is not None:
            self.Shape.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Shape', pretty_print=pretty_print)
        for String_ in self.String:
            String_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='String', pretty_print=pretty_print)
        for SP_ in self.SP:
            SP_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SP', pretty_print=pretty_print)
        if self.HYP is not None:
            self.HYP.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HYP', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_TextLineID(self.ID)    # validate type TextLineID
        value = find_attr_value_('STYLEREFS', node)
        if value is not None and 'STYLEREFS' not in already_processed:
            already_processed.add('STYLEREFS')
            self.STYLEREFS = value
        value = find_attr_value_('TAGREFS', node)
        if value is not None and 'TAGREFS' not in already_processed:
            already_processed.add('TAGREFS')
            self.TAGREFS = value
        value = find_attr_value_('PROCESSINGREFS', node)
        if value is not None and 'PROCESSINGREFS' not in already_processed:
            already_processed.add('PROCESSINGREFS')
            self.PROCESSINGREFS = value
        value = find_attr_value_('HEIGHT', node)
        if value is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            try:
                self.HEIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HEIGHT): %s' % exp)
        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            try:
                self.WIDTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WIDTH): %s' % exp)
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
        value = find_attr_value_('BASELINE', node)
        if value is not None and 'BASELINE' not in already_processed:
            already_processed.add('BASELINE')
            try:
                self.BASELINE = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (BASELINE): %s' % exp)
        value = find_attr_value_('LANG', node)
        if value is not None and 'LANG' not in already_processed:
            already_processed.add('LANG')
            self.LANG = value
        value = find_attr_value_('CS', node)
        if value is not None and 'CS' not in already_processed:
            already_processed.add('CS')
            if value in ('true', '1'):
                self.CS = True
            elif value in ('false', '0'):
                self.CS = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Shape':
            obj_ = ShapeType.factory(parent_object_=self)
            obj_.build(child_)
            self.Shape = obj_
            obj_.original_tagname_ = 'Shape'
        elif nodeName_ == 'String':
            obj_ = StringType.factory(parent_object_=self)
            obj_.build(child_)
            self.String.append(obj_)
            obj_.original_tagname_ = 'String'
        elif nodeName_ == 'SP':
            obj_ = SPType.factory(parent_object_=self)
            obj_.build(child_)
            self.SP.append(obj_)
            obj_.original_tagname_ = 'SP'
        elif nodeName_ == 'HYP':
            obj_ = HYPType.factory(parent_object_=self)
            obj_.build(child_)
            self.HYP = obj_
            obj_.original_tagname_ = 'HYP'
# end class TextLineType


class HYPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HEIGHT=None, WIDTH=None, HPOS=None, VPOS=None, CONTENT=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.HEIGHT = _cast(float, HEIGHT)
        self.WIDTH = _cast(float, WIDTH)
        self.HPOS = _cast(float, HPOS)
        self.VPOS = _cast(float, VPOS)
        self.CONTENT = _cast(None, CONTENT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HYPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HYPType.subclass:
            return HYPType.subclass(*args_, **kwargs_)
        else:
            return HYPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HEIGHT(self):
        return self.HEIGHT
    def set_HEIGHT(self, HEIGHT):
        self.HEIGHT = HEIGHT
    def get_WIDTH(self):
        return self.WIDTH
    def set_WIDTH(self, WIDTH):
        self.WIDTH = WIDTH
    def get_HPOS(self):
        return self.HPOS
    def set_HPOS(self, HPOS):
        self.HPOS = HPOS
    def get_VPOS(self):
        return self.VPOS
    def set_VPOS(self, VPOS):
        self.VPOS = VPOS
    def get_CONTENT(self):
        return self.CONTENT
    def set_CONTENT(self, CONTENT):
        self.CONTENT = CONTENT
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HYPType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HYPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HYPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HYPType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HYPType'):
        if self.HEIGHT is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            outfile.write(' HEIGHT="%s"' % self.gds_format_float(self.HEIGHT, input_name='HEIGHT'))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH="%s"' % self.gds_format_float(self.WIDTH, input_name='WIDTH'))
        if self.HPOS is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            outfile.write(' HPOS="%s"' % self.gds_format_float(self.HPOS, input_name='HPOS'))
        if self.VPOS is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            outfile.write(' VPOS="%s"' % self.gds_format_float(self.VPOS, input_name='VPOS'))
        if self.CONTENT is not None and 'CONTENT' not in already_processed:
            already_processed.add('CONTENT')
            outfile.write(' CONTENT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONTENT), input_name='CONTENT')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HYPType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('HEIGHT', node)
        if value is not None and 'HEIGHT' not in already_processed:
            already_processed.add('HEIGHT')
            try:
                self.HEIGHT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HEIGHT): %s' % exp)
        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            try:
                self.WIDTH = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WIDTH): %s' % exp)
        value = find_attr_value_('HPOS', node)
        if value is not None and 'HPOS' not in already_processed:
            already_processed.add('HPOS')
            try:
                self.HPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HPOS): %s' % exp)
        value = find_attr_value_('VPOS', node)
        if value is not None and 'VPOS' not in already_processed:
            already_processed.add('VPOS')
            try:
                self.VPOS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (VPOS): %s' % exp)
        value = find_attr_value_('CONTENT', node)
        if value is not None and 'CONTENT' not in already_processed:
            already_processed.add('CONTENT')
            self.CONTENT = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HYPType


class XmlDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XmlDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XmlDataType.subclass:
            return XmlDataType.subclass(*args_, **kwargs_)
        else:
            return XmlDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XmlDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XmlDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XmlDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XmlDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XmlDataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XmlDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'XmlDataType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class XmlDataType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'alto'
        rootClass = alto
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'alto'
        rootClass = alto
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'alto'
        rootClass = alto
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'alto'
        rootClass = alto
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ocrd_alto_generateds import *\n\n')
        sys.stdout.write('import ocrd_alto_generateds as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ALTERNATIVEType",
    "BlockType",
    "CircleType",
    "ComposedBlockType",
    "DescriptionType",
    "EllipseType",
    "GlyphType",
    "GraphicalElementType",
    "HYPType",
    "IllustrationType",
    "LayoutType",
    "OCRProcessingType",
    "PageSpaceType",
    "PageType",
    "ParagraphStyleType",
    "PolygonType",
    "ProcessingType",
    "SPType",
    "ShapeType",
    "StringType",
    "StylesType",
    "TagType",
    "TagsType",
    "TextBlockType",
    "TextLineType",
    "TextStyleType",
    "VariantType",
    "XmlDataType",
    "altoType",
    "documentIdentifierType",
    "fileIdentifierType",
    "ocrProcessingType",
    "processingSoftwareType",
    "processingStepType",
    "sourceImageInformationType"
]
